<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>stack.blog</title>
    <link>https://github.com/songMW/stack.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description></description>
    <pubDate>Wed, 10 Jan 2018 06:51:15 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ImageI/O编解码</title>
      <link>https://github.com/songMW/stack.github.io/2018/01/09/Objective-C/Image/ImageI-O%E7%BC%96%E8%A7%A3%E7%A0%81/</link>
      <guid>https://github.com/songMW/stack.github.io/2018/01/09/Objective-C/Image/ImageI-O%E7%BC%96%E8%A7%A3%E7%A0%81/</guid>
      <pubDate>Tue, 09 Jan 2018 10:56:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;解码&quot;&gt;&lt;a href=&quot;#解码&quot; class=&quot;headerlink&quot; title=&quot;解码&quot;&gt;&lt;/a&gt;解码&lt;/h2&gt;&lt;p&gt;将已经编码后的图像数据格式转化为可以被渲染的数据。&lt;br&gt;Image/IO的解码，支持了常见的图像格式，包括PNG、APNG、JPEG、GI
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>将已经编码后的图像数据格式转化为可以被渲染的数据。<br>Image/IO的解码，支持了常见的图像格式，包括PNG、APNG、JPEG、GIF、BMP、TIFF <code>CGImageSourceCopyTypeIdentifiers</code> 可以获取支持的图像格式。<br>在iOS 11之后支持了HEIC（即使用了HEVC编码的HEIF格式）。</p><h3 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h3><p>静态图的解码步骤：</p><ol><li>创建CGImageSource；</li><li>读取图像格式元数据；</li><li>解码得到CGImage；</li><li>生成上层的UIImage，清理。<h4 id="创建CGImageSource"><a href="#创建CGImageSource" class="headerlink" title="创建CGImageSource"></a>创建CGImageSource</h4>CGImageSouce，表示的是一个待解码数据的输入。</li></ol><ul><li>CGImageSourceCreateWithData： 二进制数据（CGData）中创建ImageSource；</li><li>CGImageSourceCreateWithURL： 指定一个URL创建ImageSource；</li><li>CGImageSourceCreateWithDataProvider：从DataProvide中创建ImageSource，DataProvider提供了很多种输入，包括内存，文件，网络，流等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;14444473,2560,1600&quot; ofType:@&quot;jpg&quot;];</div><div class="line">NSData *data = [NSData dataWithContentsOfFile:path];</div><div class="line"></div><div class="line">CFDataRef dataRef = (__bridge CFDataRef)data;</div><div class="line">// 创建CGImageSource</div><div class="line">CGImageSourceRef sourceRef = CGImageSourceCreateWithData(dataRef, NULL);</div><div class="line">NSAssert(sourceRef != nil, @&quot;sourceRef is nil&quot;);</div><div class="line"></div><div class="line">// 读取图像格式元数据</div><div class="line">NSDictionary *imageProperties = (__bridge NSDictionary *)CGImageSourceCopyPropertiesAtIndex(sourceRef, 0, NULL);</div><div class="line">NSLog(@&quot;获取属性列表：%@&quot;, imageProperties);</div><div class="line">NSUInteger width = [imageProperties[(__bridge NSString *)kCGImagePropertyPixelWidth] unsignedIntegerValue];</div><div class="line">NSLog(@&quot;图片宽：%@&quot;, @(width));</div><div class="line">NSUInteger height = [imageProperties[(__bridge NSString *)kCGImagePropertyPixelHeight] unsignedIntegerValue];</div><div class="line">NSLog(@&quot;图片高：%@&quot;, @(height));</div><div class="line">BOOL hasAlpha = [imageProperties[(__bridge NSString *)kCGImagePropertyHasAlpha] boolValue];</div><div class="line">NSLog(@&quot;是否含有Alpha通道：%@&quot;, @(hasAlpha));</div><div class="line">//图像格式：CGImageSourceGetType</div><div class="line">CFStringRef stringRef = CGImageSourceGetType(sourceRef);</div><div class="line">NSLog(@&quot;图像格式：%@&quot;, (__bridge NSString *)stringRef);</div><div class="line">//图像数量（动图）：CGImageSourceGetCount</div><div class="line">size_t t = CGImageSourceGetCount(sourceRef);</div><div class="line">NSLog(@&quot;图像数量：%zu&quot;, t);</div><div class="line"></div><div class="line">// 解码得到CGImage</div><div class="line">CGImageRef imageRef = CGImageSourceCreateImageAtIndex(sourceRef, 0, NULL);</div><div class="line"></div><div class="line">// 生成UIImage</div><div class="line">UIImage *image = [UIImage imageWithCGImage:imageRef];</div><div class="line">self.showImageView.image = image;</div><div class="line">CGImageRelease(imageRef);</div><div class="line">CFRelease(sourceRef);</div></pre></td></tr></table></figure></li></ul><p>注意点：</p><ol><li><code>CGImageSourceCreateImageAtIndex</code> 对于静态图 index 传0；</li><li><code>CGImageSourceCopyPropertiesAtIndex</code>  获取图片的元信息</li><li>释放</li></ol><h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3>]]></content:encoded>
      
      <comments>https://github.com/songMW/stack.github.io/2018/01/09/Objective-C/Image/ImageI-O%E7%BC%96%E8%A7%A3%E7%A0%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ImageI/O</title>
      <link>https://github.com/songMW/stack.github.io/2018/01/08/Objective-C/Image/ImageI:O/</link>
      <guid>https://github.com/songMW/stack.github.io/2018/01/08/Objective-C/Image/ImageI:O/</guid>
      <pubDate>Mon, 08 Jan 2018 11:24:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;使用Image-I-O-基础&quot;&gt;&lt;a href=&quot;#使用Image-I-O-基础&quot; class=&quot;headerlink&quot; title=&quot;使用Image I/O 基础&quot;&gt;&lt;/a&gt;使用Image I/O 基础&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ImageI/O framewo
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="使用Image-I-O-基础"><a href="#使用Image-I-O-基础" class="headerlink" title="使用Image I/O 基础"></a>使用Image I/O 基础</h2><p><code>ImageI/O framework</code>  提供从源图像 <code>CGImageSourceRef</code> 读取数据的不透明的数据类型并且写入图片数据到目的地 <code>CGImageDestinationRef</code>。它支持多种图像格式，包括标准的Web格式、高动态范围的图像和原始的摄像机数据。</p><ul><li>一个URL被认为是 <code>Core Foundation</code> 的数据类型 <code>CFURLRef : A reference to a CFURL object.</code>;</li><li><code>Core Foundation</code> 的对象 <code>CFDataRef</code> 和 <code>CFMutableDataRef</code>;</li><li>data consumer  对象<code>CGDataConsumerRef : An abstraction for data-writing tasks that eliminates the need to manage a raw memory buffer.</code> 和 数据提供对象 <code>CGDataProviderRef:</code> 抽象的数据读取任务，不用管理内存缓存;</li></ul><p>CGDataProviderRef：来自 <code>CFTypeRef</code> 并继承了所有 <code>Core Foundation</code> 的所有共有属性</p><blockquote><p>typedef struct CF_BRIDGED_TYPE(id) CGDataProvider *CGDataProviderRef;</p></blockquote><p>CFTypeRef ：<code>Core Foundation</code> 的基础类型，在多态函数中被用作类型和返回值，是一个通用的对象引用，充当其他<code>Core Foundation</code> 对象的占位符</p><blockquote><p>/<em> Base “type” of all “CF objects”, and polymorphic functions on them </em>/<br>typedef const CF_BRIDGED_TYPE(id) void * CFTypeRef;</p></blockquote><h2 id="工程中使用Image-I-O"><a href="#工程中使用Image-I-O" class="headerlink" title="工程中使用Image I/O"></a>工程中使用Image I/O</h2><blockquote><p> #import <imageio imageio.h=""></imageio></p></blockquote><h2 id="支持的图片类型"><a href="#支持的图片类型" class="headerlink" title="支持的图片类型"></a>支持的图片类型</h2><p><code>ImageI/O framework</code>  支持大多数常见的图片文件格式，比如： JPEG, JPEG2000, RAW, TIFF, BMP, and PNG</p><h3 id="获取最新的I-O支持的图片列表"><a href="#获取最新的I-O支持的图片列表" class="headerlink" title="获取最新的I/O支持的图片列表"></a>获取最新的I/O支持的图片列表</h3><ul><li><code>CGImageSourceCopyTypeIdentifiers</code> 返回一个 <code>UTIs</code> 数组是 <code>ImageI/O</code> 支持的图片来源</li><li><code>CGImageDestinationCopyTypeIdentifiers</code>  返回一个 <code>UTIs</code> 数组是 <code>ImageI/O</code> 支持的图片目标</li></ul><p>Getting and printing supported UTIs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CFArrayRef mySourceTypes = CGImageSourceCopyTypeIdentifiers();</div><div class="line">CFShow(mySourceTypes);</div><div class="line">CFArrayRef myDestinationTypes = CGImageDestinationCopyTypeIdentifiers();</div><div class="line">CFShow(myDestinationTypes);</div></pre></td></tr></table></figure></p><p>UTLs 和 图片内容类型常量</p><table><thead><tr><th>Uniform type identifier</th><th style="text-align:right">Image content type constant</th></tr></thead><tbody><tr><td>public.image</td><td style="text-align:right">kUTTypeImage</td></tr><tr><td>public.png</td><td style="text-align:right">kUTTypePNG</td></tr><tr><td>public.jpeg</td><td style="text-align:right">kUTTypeJPEG</td></tr><tr><td>public.jpeg-2000 (OS X only)</td><td style="text-align:right">kUTTypeJPEG2000</td></tr><tr><td>public.tiff</td><td style="text-align:right">kUTTypeTIFF</td></tr><tr><td>com.apple.pict (OS X only)</td><td style="text-align:right">kUTTypePICT</td></tr><tr><td>com.compuserve.gif</td><td style="text-align:right">kUTTypeGIF</td></tr></tbody></table><h2 id="实现图片渐进式"><a href="#实现图片渐进式" class="headerlink" title="实现图片渐进式"></a>实现图片渐进式</h2><p>总结步骤：</p><ol><li>获取图片 NSData 数据；</li><li>调用 <code>CGImageSourceCreateIncremental</code> 方法创建增量图片源；</li><li>根据获取到的 NSData 创建 CFData 对象；</li><li>调用 <code>CGImageSourceUpdateData</code>  来更新图片。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    self.data = [NSMutableData data];</div><div class="line">    _loadFinished = NO;</div><div class="line">    _dataLength = 0;</div><div class="line"></div><div class="line">    _sourceRef = CGImageSourceCreateIncremental(NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)loadImageWithUrl</div><div class="line">&#123;</div><div class="line">    NSURL *url = [NSURL URLWithString:imageURL];</div><div class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc]init]];</div><div class="line">    NSURLSessionDataTask *task = [session dataTaskWithURL:url];</div><div class="line">    [task resume];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.data appendData:data];</div><div class="line">    _loadFinished = NO;</div><div class="line">    if (_dataLength == dataTask.response.expectedContentLength) &#123;</div><div class="line">        _loadFinished = YES;</div><div class="line">    &#125;</div><div class="line">    _dataLength = dataTask.countOfBytesReceived;</div><div class="line">    [self showImage:self.data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)showImage:(NSData *)data</div><div class="line">&#123;</div><div class="line">    CFDataRef dataRef = (__bridge CFDataRef)data;</div><div class="line">    CGImageSourceUpdateData(_sourceRef, dataRef, _loadFinished);</div><div class="line">    CGImageRef imageRef = CGImageSourceCreateImageAtIndex(_sourceRef, 0, NULL);</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        self.showImageView.image = [UIImage imageWithCGImage:imageRef];</div><div class="line">        CGImageRelease(imageRef);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>到此应该就可以看到效果。<br>注意点：</p><ul><li>使用<code>CGImageSourceCreateImageAtIndex</code> 创建  <code>CGImageRef</code> 对象，需要手动释放，否则内存会骤增；</li><li>需要在主线程中更新UI。</li></ul>]]></content:encoded>
      
      <comments>https://github.com/songMW/stack.github.io/2018/01/08/Objective-C/Image/ImageI:O/#disqus_thread</comments>
    </item>
    
    <item>
      <title>图片压缩</title>
      <link>https://github.com/songMW/stack.github.io/2018/01/02/Objective-C/Image/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</link>
      <guid>https://github.com/songMW/stack.github.io/2018/01/02/Objective-C/Image/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</guid>
      <pubDate>Tue, 02 Jan 2018 08:31:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;PNG-和-JPEG（JPG）区别&quot;&gt;&lt;a href=&quot;#PNG-和-JPEG（JPG）区别&quot; class=&quot;headerlink&quot; title=&quot;PNG 和 JPEG（JPG）区别&quot;&gt;&lt;/a&gt;PNG 和 JPEG（JPG）区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;PNG 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="PNG-和-JPEG（JPG）区别"><a href="#PNG-和-JPEG（JPG）区别" class="headerlink" title="PNG 和 JPEG（JPG）区别"></a>PNG 和 JPEG（JPG）区别</h2><ol><li>PNG 图片是无损压缩，并且支持 alpha 通道，</li><li>JPEG 图片是有损压缩，可以指定 0-100% 的压缩比；</li><li>苹果提供了两个函数用来生成 PNG 和 JPEG 图片：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</div><div class="line">UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);</div><div class="line"></div><div class="line">// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)</div><div class="line">UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);</div></pre></td></tr></table></figure><h2 id="图片为什么需要解压图片"><a href="#图片为什么需要解压图片" class="headerlink" title="图片为什么需要解压图片"></a>图片为什么需要解压图片</h2><p>图片的解压缩需要消耗大量的 CPU 时间，为什么需要将图片解压后才能展示到屏幕上呢？这里引入一个概念<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3" target="_blank" rel="external">位图</a></p><blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.<br> 位图就是一个数组，数组中每个元素代表图片中的一个点。</p></blockquote><h3 id="获取图片的原始数据"><a href="#获取图片的原始数据" class="headerlink" title="获取图片的原始数据"></a>获取图片的原始数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFDataRef ref = CGDataProviderCopyData(CGImageGetDataProvider(_image.CGImage));</div></pre></td></tr></table></figure><h3 id="计算图片所占内存"><a href="#计算图片所占内存" class="headerlink" title="计算图片所占内存"></a>计算图片所占内存</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_image = [UIImage imageNamed:@&quot;320x480&quot;];</div><div class="line">CGFloat cgImageBytesPerRow = CGImageGetBytesPerRow(_image.CGImage); // 2560</div><div class="line">CGFloat cgImageHeight = CGImageGetHeight(_image.CGImage); // 960</div><div class="line">NSUInteger size  = cgImageHeight * cgImageBytesPerRow;</div><div class="line">NSLog(@&quot;size:%lu&quot;,(unsigned long)size); // 输出 2457600 bytes</div></pre></td></tr></table></figure><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFDataRef ref = CGDataProviderCopyData(CGImageGetDataProvider(_image.CGImage));</div><div class="line">NSLog(@&quot;%@&quot;, ref); // 输出 2457600 bytes</div></pre></td></tr></table></figure><p>打印可以看出一张320*480的图片加载并成功展示到页面所占用的内存达到 2457600 / 1024 / 1024 大约有2.34375M。如果有很多张这样的图片，内存完全不够用。</p><p>这里位图和二进制不是一个概念。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h3 id="等比压缩-常用"><a href="#等比压缩-常用" class="headerlink" title="等比压缩 常用"></a>等比压缩 常用</h3><p>使用场景：后台返回固定图片尺寸用于支持iOS和android，比如返回1920x1080大小的图片，如不压缩在iPhone的所有尺寸展示：</p><ol><li>全屏展示：图片展示不全；</li><li>指定其他大小尺寸展示：图片会失真</li></ol><p>此时需要按照等比压缩的方式来压缩图片：假定后台服务器返回图片的尺寸是固定的。<br>在程序中写定图片的宽和高：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define image_width 1080</div><div class="line">#define image_height 1920</div></pre></td></tr></table></figure></p><p>按需求来设定图片展示大小，假设想要在width * height 大小的地方展示图片，如何计算压缩后图片的大小？</p><ol><li><p>定宽<br>图片宽：width<br>图片高：width * image_height / image_width</p></li><li><p>定高<br>图片宽：height * image_width / image_height<br>图片高：height<br>计算完成后在根据压缩后图片的大小来调整展示view的大小。<br>如果服务器返回的图片尺寸不是固定的也可以进行压缩，只是每次计算之前先要获取到图片，拿到图片的大小，过程一样。</p></li></ol>]]></content:encoded>
      
      <comments>https://github.com/songMW/stack.github.io/2018/01/02/Objective-C/Image/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何判断图片类型</title>
      <link>https://github.com/songMW/stack.github.io/2018/01/01/Objective-C/Image/ImageType/</link>
      <guid>https://github.com/songMW/stack.github.io/2018/01/01/Objective-C/Image/ImageType/</guid>
      <pubDate>Mon, 01 Jan 2018 04:03:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;直接获取扩展名&quot;&gt;&lt;a href=&quot;#直接获取扩展名&quot; class=&quot;headerlink&quot; title=&quot;直接获取扩展名&quot;&gt;&lt;/a&gt;直接获取扩展名&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="直接获取扩展名"><a href="#直接获取扩展名" class="headerlink" title="直接获取扩展名"></a>直接获取扩展名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *image = @&quot;xxx.png&quot;;</div><div class="line">NSString *extension = image.pathExtension.lowercaseString;</div><div class="line">NSLog(@&quot;%@&quot;,extension);</div></pre></td></tr></table></figure><p>只适用于可以获取到图片URL的时候</p><h2 id="取出图片数据的第一个字节"><a href="#取出图片数据的第一个字节" class="headerlink" title="取出图片数据的第一个字节"></a>取出图片数据的第一个字节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;414x736&quot; ofType:@&quot;png&quot;];</div><div class="line">NSData *data = [NSData dataWithContentsOfFile:path];</div><div class="line">uint8_t c;</div><div class="line">[data getBytes:&amp;c length: 1];</div><div class="line">switch (c) &#123;</div><div class="line">    case 0xFF:</div><div class="line">        return SDImageFormatJPEG;</div><div class="line">    case 0x89:</div><div class="line">        return SDImageFormatPNG;</div><div class="line">    case 0x47:</div><div class="line">        return SDImageFormatGIF;</div><div class="line">    case 0x49:</div><div class="line">    case 0x4D:</div><div class="line">        return SDImageFormatTIFF;</div><div class="line">    case 0x52: &#123;</div><div class="line">        if (data.length &gt;= 12) &#123;</div><div class="line">            //RIFF....WEBP</div><div class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</div><div class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</div><div class="line">                return SDImageFormatWebP;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    case 0x00: &#123;</div><div class="line">        if (data.length &gt;= 12) &#123;</div><div class="line">            //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</div><div class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</div><div class="line">            if ([testString isEqualToString:@&quot;ftypheic&quot;] ||</div><div class="line">                [testString isEqualToString:@&quot;ftypheix&quot;] ||</div><div class="line">                [testString isEqualToString:@&quot;ftyphevc&quot;] ||</div><div class="line">                [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</div><div class="line">                return SDImageFormatHEIC;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>类型参考SDWebImage。</p>]]></content:encoded>
      
      <comments>https://github.com/songMW/stack.github.io/2018/01/01/Objective-C/Image/ImageType/#disqus_thread</comments>
    </item>
    
    <item>
      <title>硬币排成线</title>
      <link>https://github.com/songMW/stack.github.io/2017/07/25/Arithmetic/%E7%A1%AC%E5%B8%81%E6%8E%92%E6%88%90%E7%BA%BF/</link>
      <guid>https://github.com/songMW/stack.github.io/2017/07/25/Arithmetic/%E7%A1%AC%E5%B8%81%E6%8E%92%E6%88%90%E7%BA%BF/</guid>
      <pubDate>Tue, 25 Jul 2017 06:38:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">有 n 个硬币排成一条线. 两个参赛者轮流从右边依次拿走 1 或 2 个硬币, 直到没有硬币为止. 拿到最后一枚硬币的人获胜.请判定: 第一个玩家是输还是赢？</div><div class="line">样例:</div><div class="line">n = 1, 返回 true.</div><div class="line">n = 2, 返回 true.</div><div class="line">n = 3, 返回 false.</div><div class="line">n = 4, 返回 true.</div><div class="line">n = 5, 返回 true.</div></pre></td></tr></table></figure><h2 id="分析-博弈的思想"><a href="#分析-博弈的思想" class="headerlink" title="分析: 博弈的思想"></a>分析: 博弈的思想</h2><ol><li>每人每次只能拿一或两枚硬币;</li><li>如果先拿的人要赢, 只要最后剩下一枚或者两枚硬币即可;<br>由2可知: 一个整数对3取余时, 余数只能是0, 1, 2, 如果余数为0时, 后拿的人会赢; </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    /**</div><div class="line">    * @param n: an integer</div><div class="line">    * @return: a boolean which equals to true if the first player will win</div><div class="line">    */</div><div class="line">    bool firstWillWin(int n) &#123;</div><div class="line">        // 当n % 3 == 0时, 第一个先拿的人会输</div><div class="line">        return !(n % 3 == 0); </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://github.com/songMW/stack.github.io/2017/07/25/Arithmetic/%E7%A1%AC%E5%B8%81%E6%8E%92%E6%88%90%E7%BA%BF/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
