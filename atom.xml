<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>stack.blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/songMW/stack.github.io/"/>
  <updated>2018-01-16T10:41:42.372Z</updated>
  <id>https://github.com/songMW/stack.github.io/</id>
  
  <author>
    <name>stack</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ImageI/O编解码</title>
    <link href="https://github.com/songMW/stack.github.io/2018/01/09/Objective-C/Image/ImageI-O%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>https://github.com/songMW/stack.github.io/2018/01/09/Objective-C/Image/ImageI-O编解码/</id>
    <published>2018-01-09T10:56:07.000Z</published>
    <updated>2018-01-16T10:41:42.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><p>将已经编码后的图像数据格式转化为可以被渲染的数据。<br>Image/IO的解码，支持了常见的图像格式，包括PNG、APNG、JPEG、GIF、BMP、TIFF <code>CGImageSourceCopyTypeIdentifiers</code> 可以获取支持的图像格式。<br>在iOS 11之后支持了HEIC（即使用了HEVC编码的HEIF格式）。</p><h2 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h2><p>静态图的解码步骤：</p><ol><li>创建CGImageSource；</li><li>读取图像格式元数据；</li><li>解码得到CGImage；</li><li>生成上层的UIImage，清理。<br>创建CGImageSource<br>CGImageSouce，表示的是一个待解码数据的输入。</li></ol><ul><li>CGImageSourceCreateWithData： 二进制数据（CGData）中创建ImageSource；</li><li>CGImageSourceCreateWithURL： 指定一个URL创建ImageSource；</li><li>CGImageSourceCreateWithDataProvider：从DataProvide中创建ImageSource，DataProvider提供了很多种输入，包括内存，文件，网络，流等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;14444473,2560,1600&quot; ofType:@&quot;jpg&quot;];</div><div class="line">NSData *data = [NSData dataWithContentsOfFile:path];</div><div class="line"></div><div class="line">CFDataRef dataRef = (__bridge CFDataRef)data;</div><div class="line">// 创建CGImageSource</div><div class="line">CGImageSourceRef sourceRef = CGImageSourceCreateWithData(dataRef, NULL);</div><div class="line">NSAssert(sourceRef != nil, @&quot;sourceRef is nil&quot;);</div><div class="line"></div><div class="line">// 读取图像格式元数据</div><div class="line">NSDictionary *imageProperties = (__bridge NSDictionary *)CGImageSourceCopyPropertiesAtIndex(sourceRef, 0, NULL);</div><div class="line">NSLog(@&quot;获取属性列表：%@&quot;, imageProperties);</div><div class="line">NSUInteger width = [imageProperties[(__bridge NSString *)kCGImagePropertyPixelWidth] unsignedIntegerValue];</div><div class="line">NSLog(@&quot;图片宽：%@&quot;, @(width));</div><div class="line">NSUInteger height = [imageProperties[(__bridge NSString *)kCGImagePropertyPixelHeight] unsignedIntegerValue];</div><div class="line">NSLog(@&quot;图片高：%@&quot;, @(height));</div><div class="line">BOOL hasAlpha = [imageProperties[(__bridge NSString *)kCGImagePropertyHasAlpha] boolValue];</div><div class="line">NSLog(@&quot;是否含有Alpha通道：%@&quot;, @(hasAlpha));</div><div class="line">//图像格式：CGImageSourceGetType</div><div class="line">CFStringRef stringRef = CGImageSourceGetType(sourceRef);</div><div class="line">NSLog(@&quot;图像格式：%@&quot;, (__bridge NSString *)stringRef);</div><div class="line">//图像数量（动图）：CGImageSourceGetCount</div><div class="line">size_t t = CGImageSourceGetCount(sourceRef);</div><div class="line">NSLog(@&quot;图像数量：%zu&quot;, t);</div><div class="line"></div><div class="line">// 解码得到CGImage</div><div class="line">CGImageRef imageRef = CGImageSourceCreateImageAtIndex(sourceRef, 0, NULL);</div><div class="line"></div><div class="line">// 生成UIImage</div><div class="line">UIImage *image = [UIImage imageWithCGImage:imageRef];</div><div class="line">self.showImageView.image = image;</div><div class="line">CGImageRelease(imageRef);</div><div class="line">CFRelease(sourceRef);</div></pre></td></tr></table></figure></li></ul><p>注意点：</p><ol><li><code>CGImageSourceCreateImageAtIndex</code> 对于静态图 index 传0；</li><li><code>CGImageSourceCopyPropertiesAtIndex</code>  获取图片的元信息</li><li>释放</li></ol><h2 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h2><ol><li>创建CGImageSource ；</li><li>使用<code>CGImageSourceGetCount</code>获取到图片的帧数；</li><li>循环遍历每一帧，循环静态图2～4步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:dynamicImageURL];</div><div class="line">CGImageSourceRef sourcesRef = CGImageSourceCreateWithURL((__bridge_retained CFURLRef)url, NULL);</div><div class="line"></div><div class="line">// 获取图片帧数</div><div class="line">size_t count = CGImageSourceGetCount(sourcesRef);</div><div class="line">NSMutableArray&lt;UIImage *&gt; *images = [NSMutableArray array];</div><div class="line">double totalDuration = 0;</div><div class="line">for (size_t i = 0; i &lt; count; i++) &#123;</div><div class="line">NSDictionary *propertiesDict = (__bridge_transfer NSDictionary *)CGImageSourceCopyPropertiesAtIndex(sourcesRef, i, NULL);</div><div class="line">NSDictionary *gitPropertiesDict = propertiesDict[(NSString *)kCGImagePropertyGIFDictionary];</div><div class="line">double duration = [gitPropertiesDict[(NSString *)kCGImagePropertyGIFUnclampedDelayTime] doubleValue]; // GIF原始的帧持续时长，秒数</div><div class="line">totalDuration += duration;</div><div class="line">CGImageRef imageRef = CGImageSourceCreateImageAtIndex(sourcesRef, i, NULL);</div><div class="line">UIImage *image  = [UIImage imageWithCGImage:imageRef];</div><div class="line">[images addObject:image];</div><div class="line">CGImageRelease(imageRef);</div><div class="line">&#125;</div><div class="line">self.showImageView.image = [UIImage animatedImageWithImages:images duration:totalDuration];</div></pre></td></tr></table></figure></li></ol><p>UIImage这个animatedImages的接口，会根据传入的images的数量，平均分配传入的totalDuration的展示时长</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>指的就是将一个UIImage表示的图像，编码为对应图像格式的数据，输出NSData的过程。Image/IO提供的对应概念，叫做CGImageDestination，表示一个输出。之后的编码相关的操作与Destination对应。</p><h2 id="静态图-1"><a href="#静态图-1" class="headerlink" title="静态图"></a>静态图</h2><p>静态图编码步骤：</p><ol><li>创建CGImageDestination；</li><li>添加图像格式元数据（可选）和CGImage；</li><li>编码得到NSData。</li></ol><p>创建 CGImageDestination：</p><ol><li><code>CGImageDestinationCreateWithURL</code></li><li><code>CGImageDestinationCreateWithData</code></li><li><code>CGImageDestinationCreateWithDataConsumer</code></li></ol><p>添加图片到CGImageDestination</p><ol><li><code>CGImageDestinationAddImage</code></li><li><code>CGImageDestinationAddImageFromSource</code></li></ol><p>验证是否添加完成<br>使用<code>CGImageDestinationFinalize</code>验证图片是否添加完成，一旦完成后就不能向图片添加更多的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure><h2 id="动态图-1"><a href="#动态图-1" class="headerlink" title="动态图"></a>动态图</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解码&quot;&gt;&lt;a href=&quot;#解码&quot; class=&quot;headerlink&quot; title=&quot;解码&quot;&gt;&lt;/a&gt;解码&lt;/h1&gt;&lt;p&gt;将已经编码后的图像数据格式转化为可以被渲染的数据。&lt;br&gt;Image/IO的解码，支持了常见的图像格式，包括PNG、APNG、JPEG、GI
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="Image" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/"/>
    
      <category term="ImageI/O编解码" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/ImageI-O%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>ImageI/O</title>
    <link href="https://github.com/songMW/stack.github.io/2018/01/08/Objective-C/Image/ImageI:O/"/>
    <id>https://github.com/songMW/stack.github.io/2018/01/08/Objective-C/Image/ImageI:O/</id>
    <published>2018-01-08T11:24:01.000Z</published>
    <updated>2018-01-16T10:41:47.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Image-I-O-基础"><a href="#使用Image-I-O-基础" class="headerlink" title="使用Image I/O 基础"></a>使用Image I/O 基础</h2><p><code>ImageI/O framework</code>  提供从源图像 <code>CGImageSourceRef</code> 读取数据的不透明的数据类型并且写入图片数据到目的地 <code>CGImageDestinationRef</code>。它支持多种图像格式，包括标准的Web格式、高动态范围的图像和原始的摄像机数据。</p><ul><li>一个URL被认为是 <code>Core Foundation</code> 的数据类型 <code>CFURLRef : A reference to a CFURL object.</code>;</li><li><code>Core Foundation</code> 的对象 <code>CFDataRef</code> 和 <code>CFMutableDataRef</code>;</li><li>data consumer  对象<code>CGDataConsumerRef : An abstraction for data-writing tasks that eliminates the need to manage a raw memory buffer.</code> 和 数据提供对象 <code>CGDataProviderRef:</code> 抽象的数据读取任务，不用管理内存缓存;</li></ul><p>CGDataProviderRef：来自 <code>CFTypeRef</code> 并继承了所有 <code>Core Foundation</code> 的所有共有属性</p><blockquote><p>typedef struct CF_BRIDGED_TYPE(id) CGDataProvider *CGDataProviderRef;</p></blockquote><p>CFTypeRef ：<code>Core Foundation</code> 的基础类型，在多态函数中被用作类型和返回值，是一个通用的对象引用，充当其他<code>Core Foundation</code> 对象的占位符</p><blockquote><p>/<em> Base “type” of all “CF objects”, and polymorphic functions on them </em>/<br>typedef const CF_BRIDGED_TYPE(id) void * CFTypeRef;</p></blockquote><h2 id="工程中使用Image-I-O"><a href="#工程中使用Image-I-O" class="headerlink" title="工程中使用Image I/O"></a>工程中使用Image I/O</h2><blockquote><p> #import <imageio imageio.h=""></imageio></p></blockquote><h2 id="支持的图片类型"><a href="#支持的图片类型" class="headerlink" title="支持的图片类型"></a>支持的图片类型</h2><p><code>ImageI/O framework</code>  支持大多数常见的图片文件格式，比如： JPEG, JPEG2000, RAW, TIFF, BMP, and PNG</p><h3 id="获取最新的I-O支持的图片列表"><a href="#获取最新的I-O支持的图片列表" class="headerlink" title="获取最新的I/O支持的图片列表"></a>获取最新的I/O支持的图片列表</h3><ul><li><code>CGImageSourceCopyTypeIdentifiers</code> 返回一个 <code>UTIs</code> 数组是 <code>ImageI/O</code> 支持的图片来源</li><li><code>CGImageDestinationCopyTypeIdentifiers</code>  返回一个 <code>UTIs</code> 数组是 <code>ImageI/O</code> 支持的图片目标</li></ul><p>Getting and printing supported UTIs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CFArrayRef mySourceTypes = CGImageSourceCopyTypeIdentifiers();</div><div class="line">CFShow(mySourceTypes);</div><div class="line">CFArrayRef myDestinationTypes = CGImageDestinationCopyTypeIdentifiers();</div><div class="line">CFShow(myDestinationTypes);</div></pre></td></tr></table></figure></p><p>UTLs 和 图片内容类型常量</p><table><thead><tr><th>Uniform type identifier</th><th style="text-align:right">Image content type constant</th></tr></thead><tbody><tr><td>public.image</td><td style="text-align:right">kUTTypeImage</td></tr><tr><td>public.png</td><td style="text-align:right">kUTTypePNG</td></tr><tr><td>public.jpeg</td><td style="text-align:right">kUTTypeJPEG</td></tr><tr><td>public.jpeg-2000 (OS X only)</td><td style="text-align:right">kUTTypeJPEG2000</td></tr><tr><td>public.tiff</td><td style="text-align:right">kUTTypeTIFF</td></tr><tr><td>com.apple.pict (OS X only)</td><td style="text-align:right">kUTTypePICT</td></tr><tr><td>com.compuserve.gif</td><td style="text-align:right">kUTTypeGIF</td></tr></tbody></table><h2 id="实现图片渐进式"><a href="#实现图片渐进式" class="headerlink" title="实现图片渐进式"></a>实现图片渐进式</h2><p>总结步骤：</p><ol><li>获取图片 NSData 数据；</li><li>调用 <code>CGImageSourceCreateIncremental</code> 方法创建增量图片源；</li><li>根据获取到的 NSData 创建 CFData 对象；</li><li>调用 <code>CGImageSourceUpdateData</code>  来更新图片。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    self.data = [NSMutableData data];</div><div class="line">    _loadFinished = NO;</div><div class="line">    _dataLength = 0;</div><div class="line"></div><div class="line">    _sourceRef = CGImageSourceCreateIncremental(NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)loadImageWithUrl</div><div class="line">&#123;</div><div class="line">    NSURL *url = [NSURL URLWithString:imageURL];</div><div class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc]init]];</div><div class="line">    NSURLSessionDataTask *task = [session dataTaskWithURL:url];</div><div class="line">    [task resume];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.data appendData:data];</div><div class="line">    _loadFinished = NO;</div><div class="line">    if (_dataLength == dataTask.response.expectedContentLength) &#123;</div><div class="line">        _loadFinished = YES;</div><div class="line">    &#125;</div><div class="line">    _dataLength = dataTask.countOfBytesReceived;</div><div class="line">    [self showImage:self.data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)showImage:(NSData *)data</div><div class="line">&#123;</div><div class="line">    CFDataRef dataRef = (__bridge CFDataRef)data;</div><div class="line">    CGImageSourceUpdateData(_sourceRef, dataRef, _loadFinished);</div><div class="line">    CGImageRef imageRef = CGImageSourceCreateImageAtIndex(_sourceRef, 0, NULL);</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        self.showImageView.image = [UIImage imageWithCGImage:imageRef];</div><div class="line">        CGImageRelease(imageRef);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>到此应该就可以看到效果。<br>注意点：</p><ul><li>使用<code>CGImageSourceCreateImageAtIndex</code> 创建  <code>CGImageRef</code> 对象，需要手动释放，否则内存会骤增；</li><li>需要在主线程中更新UI。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Image-I-O-基础&quot;&gt;&lt;a href=&quot;#使用Image-I-O-基础&quot; class=&quot;headerlink&quot; title=&quot;使用Image I/O 基础&quot;&gt;&lt;/a&gt;使用Image I/O 基础&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ImageI/O framewo
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="Image" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/"/>
    
      <category term="ImageI/O" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/ImageI-O/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>图片压缩</title>
    <link href="https://github.com/songMW/stack.github.io/2018/01/02/Objective-C/Image/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>https://github.com/songMW/stack.github.io/2018/01/02/Objective-C/Image/图片压缩/</id>
    <published>2018-01-02T08:31:06.000Z</published>
    <updated>2018-01-16T10:41:34.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PNG-和-JPEG（JPG）区别"><a href="#PNG-和-JPEG（JPG）区别" class="headerlink" title="PNG 和 JPEG（JPG）区别"></a>PNG 和 JPEG（JPG）区别</h2><ol><li>PNG 图片是无损压缩，并且支持 alpha 通道，</li><li>JPEG 图片是有损压缩，可以指定 0-100% 的压缩比；</li><li>苹果提供了两个函数用来生成 PNG 和 JPEG 图片：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</div><div class="line">UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);</div><div class="line"></div><div class="line">// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)</div><div class="line">UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);</div></pre></td></tr></table></figure><h2 id="图片为什么需要解压图片"><a href="#图片为什么需要解压图片" class="headerlink" title="图片为什么需要解压图片"></a>图片为什么需要解压图片</h2><p>图片的解压缩需要消耗大量的 CPU 时间，为什么需要将图片解压后才能展示到屏幕上呢？这里引入一个概念<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3" target="_blank" rel="external">位图</a></p><blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.<br> 位图就是一个数组，数组中每个元素代表图片中的一个点。</p></blockquote><h3 id="获取图片的原始数据"><a href="#获取图片的原始数据" class="headerlink" title="获取图片的原始数据"></a>获取图片的原始数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CFDataRef ref = CGDataProviderCopyData(CGImageGetDataProvider(_image.CGImage));</div></pre></td></tr></table></figure><h3 id="计算图片所占内存"><a href="#计算图片所占内存" class="headerlink" title="计算图片所占内存"></a>计算图片所占内存</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_image = [UIImage imageNamed:@&quot;320x480&quot;];</div><div class="line">CGFloat cgImageBytesPerRow = CGImageGetBytesPerRow(_image.CGImage); // 2560</div><div class="line">CGFloat cgImageHeight = CGImageGetHeight(_image.CGImage); // 960</div><div class="line">NSUInteger size  = cgImageHeight * cgImageBytesPerRow;</div><div class="line">NSLog(@&quot;size:%lu&quot;,(unsigned long)size); // 输出 2457600 bytes</div></pre></td></tr></table></figure><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFDataRef ref = CGDataProviderCopyData(CGImageGetDataProvider(_image.CGImage));</div><div class="line">NSLog(@&quot;%@&quot;, ref); // 输出 2457600 bytes</div></pre></td></tr></table></figure><p>打印可以看出一张320*480的图片加载并成功展示到页面所占用的内存达到 2457600 / 1024 / 1024 大约有2.34375M。如果有很多张这样的图片，内存完全不够用。</p><p>这里位图和二进制不是一个概念。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h3 id="等比压缩-常用"><a href="#等比压缩-常用" class="headerlink" title="等比压缩 常用"></a>等比压缩 常用</h3><p>使用场景：后台返回固定图片尺寸用于支持iOS和android，比如返回1920x1080大小的图片，如不压缩在iPhone的所有尺寸展示：</p><ol><li>全屏展示：图片展示不全；</li><li>指定其他大小尺寸展示：图片会失真</li></ol><p>此时需要按照等比压缩的方式来压缩图片：假定后台服务器返回图片的尺寸是固定的。<br>在程序中写定图片的宽和高：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define image_width 1080</div><div class="line">#define image_height 1920</div></pre></td></tr></table></figure></p><p>按需求来设定图片展示大小，假设想要在width * height 大小的地方展示图片，如何计算压缩后图片的大小？</p><ol><li><p>定宽<br>图片宽：width<br>图片高：width * image_height / image_width</p></li><li><p>定高<br>图片宽：height * image_width / image_height<br>图片高：height<br>计算完成后在根据压缩后图片的大小来调整展示view的大小。<br>如果服务器返回的图片尺寸不是固定的也可以进行压缩，只是每次计算之前先要获取到图片，拿到图片的大小，过程一样。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PNG-和-JPEG（JPG）区别&quot;&gt;&lt;a href=&quot;#PNG-和-JPEG（JPG）区别&quot; class=&quot;headerlink&quot; title=&quot;PNG 和 JPEG（JPG）区别&quot;&gt;&lt;/a&gt;PNG 和 JPEG（JPG）区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;PNG 
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="Image" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/"/>
    
      <category term="图片压缩" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>如何判断图片类型</title>
    <link href="https://github.com/songMW/stack.github.io/2018/01/01/Objective-C/Image/ImageType/"/>
    <id>https://github.com/songMW/stack.github.io/2018/01/01/Objective-C/Image/ImageType/</id>
    <published>2018-01-01T04:03:34.000Z</published>
    <updated>2018-01-16T10:41:53.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直接获取扩展名"><a href="#直接获取扩展名" class="headerlink" title="直接获取扩展名"></a>直接获取扩展名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *image = @&quot;xxx.png&quot;;</div><div class="line">NSString *extension = image.pathExtension.lowercaseString;</div><div class="line">NSLog(@&quot;%@&quot;,extension);</div></pre></td></tr></table></figure><p>只适用于可以获取到图片URL的时候</p><h2 id="取出图片数据的第一个字节"><a href="#取出图片数据的第一个字节" class="headerlink" title="取出图片数据的第一个字节"></a>取出图片数据的第一个字节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;414x736&quot; ofType:@&quot;png&quot;];</div><div class="line">NSData *data = [NSData dataWithContentsOfFile:path];</div><div class="line">uint8_t c;</div><div class="line">[data getBytes:&amp;c length: 1];</div><div class="line">switch (c) &#123;</div><div class="line">    case 0xFF:</div><div class="line">        return SDImageFormatJPEG;</div><div class="line">    case 0x89:</div><div class="line">        return SDImageFormatPNG;</div><div class="line">    case 0x47:</div><div class="line">        return SDImageFormatGIF;</div><div class="line">    case 0x49:</div><div class="line">    case 0x4D:</div><div class="line">        return SDImageFormatTIFF;</div><div class="line">    case 0x52: &#123;</div><div class="line">        if (data.length &gt;= 12) &#123;</div><div class="line">            //RIFF....WEBP</div><div class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</div><div class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</div><div class="line">                return SDImageFormatWebP;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    case 0x00: &#123;</div><div class="line">        if (data.length &gt;= 12) &#123;</div><div class="line">            //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</div><div class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</div><div class="line">            if ([testString isEqualToString:@&quot;ftypheic&quot;] ||</div><div class="line">                [testString isEqualToString:@&quot;ftypheix&quot;] ||</div><div class="line">                [testString isEqualToString:@&quot;ftyphevc&quot;] ||</div><div class="line">                [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</div><div class="line">                return SDImageFormatHEIC;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>类型参考SDWebImage。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;直接获取扩展名&quot;&gt;&lt;a href=&quot;#直接获取扩展名&quot; class=&quot;headerlink&quot; title=&quot;直接获取扩展名&quot;&gt;&lt;/a&gt;直接获取扩展名&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="Image" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/"/>
    
      <category term="imageType" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Image/imageType/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>pod搜索不到解决方法</title>
    <link href="https://github.com/songMW/stack.github.io/2017/09/04/Objective-C/CrashCollection/%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/songMW/stack.github.io/2017/09/04/Objective-C/CrashCollection/搜索不到解决方法/</id>
    <published>2017-09-04T09:49:38.000Z</published>
    <updated>2018-01-16T10:47:02.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pod搜索不到"><a href="#pod搜索不到" class="headerlink" title="pod搜索不到"></a>pod搜索不到</h2><p>成功发布pod, 使用pod install可以成功添加自己发布的pod到工程,但是却用pod serach 搜索时报错: Unable to find a pod with name, author, summary, or description matching [podname]</p><ol><li>执行pod setup<br>终端输入：pod setup<br>会出现Setting up CocoaPods master repo，稍等几十秒，最底下会输出Setup completed。说明执行pod setup成功。</li><li>如果pod search操作还是搜索失败，如下：<br>终端输入：pod search [podname]<br>输出：Unable to find a pod with name, author, summary, or descriptionmatching [podname] 这时就需要继续下面的步骤了。<br>删除~/Library/Caches/CocoaPods目录下的search_index.json文件<br>pod setup成功后，依然不能pod search，是因为之前你执行pod search生成了search_index.json，此时需要删掉。</li><li>~/Library/Caches/CocoaPods/ 删除search_index.json再执行pod search<br>终端输入：pod search [podname] (不区分大小写)<br>输出：Creating search index for spec repo ‘master’.. Done!，稍等片刻······就会出现所有带有 [podname] 字段的类库。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pod搜索不到&quot;&gt;&lt;a href=&quot;#pod搜索不到&quot; class=&quot;headerlink&quot; title=&quot;pod搜索不到&quot;&gt;&lt;/a&gt;pod搜索不到&lt;/h2&gt;&lt;p&gt;成功发布pod, 使用pod install可以成功添加自己发布的pod到工程,但是却用pod se
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="CrashCollection" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/"/>
    
      <category term="pod搜索不到解决方法" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/pod%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>MPMoviePlayerController</title>
    <link href="https://github.com/songMW/stack.github.io/2017/06/30/Objective-C/AVFoundation/MoviePlayer/MPMoviePlayerController/"/>
    <id>https://github.com/songMW/stack.github.io/2017/06/30/Objective-C/AVFoundation/MoviePlayer/MPMoviePlayerController/</id>
    <published>2017-06-30T03:38:30.000Z</published>
    <updated>2018-01-16T10:40:00.186Z</updated>
    
    <content type="html"><![CDATA[<p>首先贴上<a href="https://developer.apple.com/documentation/mediaplayer/mpmovieplayercontroller" target="_blank" rel="external">官方文档</a></p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    [self.view addSubview:self.moviePlayerController.view];</div><div class="line">    [self.moviePlayerController.view makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.left.bottom.right.equalTo(self.view);</div><div class="line">    &#125;];</div><div class="line">    [self.moviePlayerController prepareToPlay];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MPMoviePlayerController *)moviePlayerController</div><div class="line">&#123;</div><div class="line">    if (!_moviePlayerController) &#123;</div><div class="line">        _moviePlayerController = [[MPMoviePlayerController alloc]init];</div><div class="line">        _moviePlayerController.fullscreen = NO;</div><div class="line">        _moviePlayerController.controlStyle = MPMovieControlStyleEmbedded;</div><div class="line">        _moviePlayerController.scalingMode = MPMovieScalingModeAspectFit;</div><div class="line">        [_moviePlayerController.view setTranslatesAutoresizingMaskIntoConstraints:NO];</div><div class="line">    &#125;</div><div class="line">    return _moviePlayerController;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>_moviePlayerController.view 一定要添加到父视图上, 要不只有声音没有图片</li><li>MPMoviePlayerController 继承 NSObject <mpmediaplayback></mpmediaplayback></li><li><mpmediaplayback> 播放, 暂停, 停止, 准备播放的API</mpmediaplayback></li><li>视图刚呈现时底部显示: 暂停 进度条 全屏按钮</li><li>点击底部全屏按钮后会在顶部呈现: Done 进度条 退出全屏按钮</li></ul><h2 id="2-顶部-Done-和-退出全屏按钮的监测"><a href="#2-顶部-Done-和-退出全屏按钮的监测" class="headerlink" title="2. 顶部 Done 和 退出全屏按钮的监测"></a>2. 顶部 Done 和 退出全屏按钮的监测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(doneButtonClick:) name:MPMoviePlayerWillExitFullscreenNotification object:nil];</div><div class="line"></div><div class="line">- (void)doneButtonClick:(NSNotification *)center</div><div class="line">&#123;</div><div class="line">    if (self.moviePlayerController.playbackState == MPMoviePlaybackStateStopped) &#123;</div><div class="line">        //说明是点击Done按钮</div><div class="line">        [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">    &#125;</div><div class="line">    else if (self.moviePlayerController.playbackState == MPMoviePlaybackStatePlaying)&#123;</div><div class="line">        //说明点击了右上角退出全屏按钮</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>注册 <code>MPMoviePlayerWillExitFullscreenNotification</code> 这个通知, 不管是点击Done还是退出全屏按钮都会接受到通知, 在通知的回调方法中可以根据 <code>playbackState</code> 这个属性来判断是点击那个按钮.</li><li>点击Done按钮时会暂停播放</li><li>点击退出全屏按钮则不会暂停播放</li></ul><h2 id="3-监听视频播放结束"><a href="#3-监听视频播放结束" class="headerlink" title="3. 监听视频播放结束"></a>3. 监听视频播放结束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(videoEndPlay:) name:MPMoviePlayerPlaybackDidFinishNotification object:nil];</div><div class="line"></div><div class="line">- (void)videoEndPlay:(NSNotification *)sender</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;播放结束&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>自动播放完成后会调用</li><li>用户退出播放时会调用</li></ul><h2 id="4-监听当前视频播放状态"><a href="#4-监听当前视频播放状态" class="headerlink" title="4. 监听当前视频播放状态"></a>4. 监听当前视频播放状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(videoLoadStateDidChange:) name:MPMoviePlayerLoadStateDidChangeNotification object:nil];</div><div class="line">- (void)videoLoadStateDidChange:(NSNotification *)sender</div><div class="line">&#123;</div><div class="line">    // Returns the network load state of the movie player</div><div class="line">    switch (self.moviePlayerController.loadState) &#123;</div><div class="line">        case MPMovieLoadStatePlayable:</div><div class="line">            NSLog(@&quot;加载完成,可以播放&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMovieLoadStatePlaythroughOK:</div><div class="line">            NSLog(@&quot;缓冲完成，可以连续播放&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMovieLoadStateStalled:</div><div class="line">            NSLog(@&quot;缓冲中&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMovieLoadStateUnknown:</div><div class="line">            NSLog(@&quot;未知状态&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-监听当前视频-Playback-拖动进度条-播放-暂停-开启全屏-退出全屏也需要注册这个通知"><a href="#5-监听当前视频-Playback-拖动进度条-播放-暂停-开启全屏-退出全屏也需要注册这个通知" class="headerlink" title="5. 监听当前视频 Playback 拖动进度条, 播放, 暂停, 开启全屏, 退出全屏也需要注册这个通知"></a>5. 监听当前视频 Playback 拖动进度条, 播放, 暂停, 开启全屏, 退出全屏也需要注册这个通知</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(videoPlaybackDidChange:) name:MPMoviePlayerPlaybackStateDidChangeNotification object:nil];</div><div class="line"></div><div class="line">- (void)videoPlaybackDidChange:(NSNotification *)center</div><div class="line">&#123;</div><div class="line">    switch (self.moviePlayerController.playbackState) &#123;</div><div class="line">        case MPMoviePlaybackStateStopped:</div><div class="line">            NSLog(@&quot;停止播放&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMoviePlaybackStatePlaying:</div><div class="line">            NSLog(@&quot;正在播放&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMoviePlaybackStatePaused:</div><div class="line">            NSLog(@&quot;暂停播放&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMoviePlaybackStateInterrupted:</div><div class="line">            NSLog(@&quot;中断播放&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMoviePlaybackStateSeekingForward:</div><div class="line">            NSLog(@&quot;快进&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        case MPMoviePlaybackStateSeekingBackward:</div><div class="line">            NSLog(@&quot;快退&quot;);</div><div class="line">            break;</div><div class="line"></div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-上一首-下一首"><a href="#7-上一首-下一首" class="headerlink" title="7. 上一首, 下一首"></a>7. 上一首, 下一首</h2><h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先贴上&lt;a href=&quot;https://developer.apple.com/documentation/mediaplayer/mpmovieplayercontroller&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="AVFoundation" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/AVFoundation/"/>
    
      <category term="MoviePlayer" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/AVFoundation/MoviePlayer/"/>
    
      <category term="MPMoviePlayerController" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/AVFoundation/MoviePlayer/MPMoviePlayerController/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>MPMoviePlayerViewController</title>
    <link href="https://github.com/songMW/stack.github.io/2017/06/29/Objective-C/AVFoundation/MoviePlayer/MPMoviePlayerViewController/"/>
    <id>https://github.com/songMW/stack.github.io/2017/06/29/Objective-C/AVFoundation/MoviePlayer/MPMoviePlayerViewController/</id>
    <published>2017-06-29T12:34:53.000Z</published>
    <updated>2018-01-16T10:40:05.665Z</updated>
    
    <content type="html"><![CDATA[<p>首先贴上<a href="https://developer.apple.com/documentation/mediaplayer/mpmovieplayercontroller" target="_blank" rel="external">官方文档</a></p><p>先看下头文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface MPMoviePlayerViewController : UIViewController</div><div class="line"></div><div class="line">- (instancetype)initWithContentURL:(NSURL *)contentURL NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">@property (nonatomic, readonly) MPMoviePlayerController *moviePlayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface UIViewController (MPMoviePlayerViewController)</div><div class="line"></div><div class="line">- (void)presentMoviePlayerViewControllerAnimated:(MPMoviePlayerViewController *)moviePlayerViewController;</div><div class="line">- (void)dismissMoviePlayerViewControllerAnimated;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p><ul><li>MPMoviePlayerViewController 继承 UIViewController;</li><li>API很少, 主要是 moviePlayer 这个属性, 是对 MPMoviePlayerController 的一层封装;</li><li>当然也拥有 MPMoviePlayerController 的所有功能;</li><li>使用简单, 点击Done按钮会自动退出, 有进度条, 快进, 快退, 播放按钮.</li><li>可以去自定义添加控件到播放页面, 不建议这么做, 可以直接使用 MPMoviePlayerController</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MPMoviePlayerViewController *mpMovieController = [[MPMoviePlayerViewController alloc]initWithContentURL:[NSURL fileURLWithPath:videoPath]];</div><div class="line">[vc presentViewController:mpMovieController animated:YES completion:nil];</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先贴上&lt;a href=&quot;https://developer.apple.com/documentation/mediaplayer/mpmovieplayercontroller&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="AVFoundation" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/AVFoundation/"/>
    
      <category term="MoviePlayer" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/AVFoundation/MoviePlayer/"/>
    
      <category term="MPMoviePlayerViewController" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/AVFoundation/MoviePlayer/MPMoviePlayerViewController/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView的坑</title>
    <link href="https://github.com/songMW/stack.github.io/2017/06/18/Objective-C/WKWebView/"/>
    <id>https://github.com/songMW/stack.github.io/2017/06/18/Objective-C/WKWebView/</id>
    <published>2017-06-18T03:05:05.000Z</published>
    <updated>2018-01-16T10:40:40.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-iOS-8-系统下遇到的问题"><a href="#一-iOS-8-系统下遇到的问题" class="headerlink" title="一: iOS 8 系统下遇到的问题"></a>一: iOS 8 系统下遇到的问题</h2><ol><li>实例化WKWebView后如果不将其添加到父类上, 则其代理方法不回调; iOS 9及以上版本不存在此问题. 大坑~</li></ol><h2 id="二-webView-自适应宽度"><a href="#二-webView-自适应宽度" class="headerlink" title="二: webView 自适应宽度"></a>二: webView 自适应宽度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView</div><div class="line">&#123;</div><div class="line">    // webView 自适应宽度</div><div class="line">    NSString *meta = [NSString stringWithFormat:@&quot;document.getElementsByName(\&quot;viewport\&quot;)[0].content = \&quot;width=%f,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\&quot;&quot;, webView.frame.size.width];</div><div class="line">    [webView stringByEvaluatingJavaScriptFromString:meta];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-iOS-8-系统下遇到的问题&quot;&gt;&lt;a href=&quot;#一-iOS-8-系统下遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;一: iOS 8 系统下遇到的问题&quot;&gt;&lt;/a&gt;一: iOS 8 系统下遇到的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;实例化WKW
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="WKWebView" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/WKWebView/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>宏(define)与常量(const)</title>
    <link href="https://github.com/songMW/stack.github.io/2017/06/17/Objective-C/Define_Const/"/>
    <id>https://github.com/songMW/stack.github.io/2017/06/17/Objective-C/Define_Const/</id>
    <published>2017-06-17T07:59:06.000Z</published>
    <updated>2018-01-16T10:40:24.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="当我们想全局共用一些数据时-可以用宏、变量、常量"><a href="#当我们想全局共用一些数据时-可以用宏、变量、常量" class="headerlink" title="当我们想全局共用一些数据时, 可以用宏、变量、常量"></a>当我们想全局共用一些数据时, 可以用宏、变量、常量</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>定义形式: #define THIS_IS_MACRO @”this is macro”<br>在预处理器里进行文本替换, 没有类型, 不做任何类型检查, 编译器可以对相同的字符串进行优化, 大量宏会导致二进制包变大</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义形式: NSString *thisIsVariable = @”this is variable”;<br>共享一块内存空间, 就算项目中N处用到, 也不会分配N块内存空间, 可以被修改, 在编译阶段会执行类型检查</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义形式: </p><ol><li>const NSString *thisIsConstVariable = @”this is const variable, value can changed”;</li><li>NSString const *thisIsConstVariable = @”this is const variable, value can changed”;</li><li>NSString *const thisIsConstVariable = @”this is const variable, value can not changed”;</li><li>static const NSString *thisIsStaticConstVariable = @”this is static const variable”;</li></ol><p>共享一块内存空间, 就算项目中N处用到, 也不会分配N块内存空间, 可以根据const修饰的位置设定能否修改, 在编译阶段会执行类型检查</p><h2 id="常量区分"><a href="#常量区分" class="headerlink" title="常量区分"></a>常量区分</h2><ol><li><p>全局常量: 不管你定义在任何文件夹,外部都能访问<br>只要在类中声明一个全局变量, 该变量在整个工程中都可以访问到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//在 ViewController 中声明一个全局变量 testSting</div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">NSString *const testSting = @&quot;hello world&quot;;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//在 AppDelegate 中可以获取到该值</div><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions </div><div class="line">&#123;</div><div class="line">    extern NSString *const testSting;</div><div class="line">    NSLog(@&quot;%@&quot;, testSting);</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>局部常量: 用static修饰后,不能提供外界访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//在 ViewController 中声明一个全局变量 testSting</div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">static NSString *const testStaticString = @&quot;static&quot;;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//在 AppDelegate 中获取</div><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions </div><div class="line">&#123;</div><div class="line">    extern NSString *const testStaticString;</div><div class="line">    NSLog(@&quot;%@&quot;, testStaticString);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//会报错</div><div class="line">Undefined symbols for architecture x86_64:</div><div class="line">&quot;_testStaticString&quot;, referenced from:</div><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:] in AppDelegate.o</div><div class="line">ld: symbol(s) not found for architecture x86_64</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure></li></ol><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern是用来声明一个已经定义过的变量, 多个类中同时声明同一个变量但却没有初始化, 当访问这个变量时会报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Undefined symbols for architecture x86_64:</div><div class="line">&quot;_testSting&quot;, referenced from:</div><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:] in AppDelegate.o</div><div class="line">ld: symbol(s) not found for architecture x86_64</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure></p><p>如果多个类中同时使用extern声明同一个变量, 定义多次, 则会报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ld: 1 duplicate symbol for architecture x86_64</div><div class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure></p><pre><code>* extern可以用来声明一个全局变量, 但是不能用来定义变量* 默认情况下, 一个全局变量是可以供多个源文件共享的, 也就说, 多个源文件中同名的全局变量都代表着同一个变量* 如果在定义全局变量的时候加上static关键字, 此时static的作用在于限制该全局变量的作用域, 只能在定义该全局变量的文件中才能使用, 跟其他源文件中的同名变量互不干扰</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;当我们想全局共用一些数据时-可以用宏、变量、常量&quot;&gt;&lt;a href=&quot;#当我们想全局共用一些数据时-可以用宏、变量、常量&quot; class=&quot;headerlink&quot; title=&quot;当我们想全局共用一些数据时, 可以用宏、变量、常量&quot;&gt;&lt;/a&gt;当我们想全局共用一些数据时
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="Define_Const" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/Define-Const/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>KVO</title>
    <link href="https://github.com/songMW/stack.github.io/2017/06/15/Objective-C/KV_X/KVO/"/>
    <id>https://github.com/songMW/stack.github.io/2017/06/15/Objective-C/KV_X/KVO/</id>
    <published>2017-06-15T02:15:23.000Z</published>
    <updated>2018-01-16T09:53:43.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是KVO"><a href="#什么是KVO" class="headerlink" title="什么是KVO?"></a>什么是KVO?</h1><blockquote><p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p></blockquote><p><strong> KVO是一种机制，被观察对象指定的属性发生变化时，观察者可以得到通知。</strong></p><blockquote><p>Important: In order to understand key-value observing, you must first understand key-value coding.</p></blockquote><h1 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h1><h2 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h2><ol><li>addObserver ：注册观察者</li><li>forKeyPath ：需要观察对象的属性</li><li>NSKeyValueObservingOptions ：当观察对象的属性值发生变化时，会发送一个通知包含 <code>NSKeyValueChangeNewKey and NSKeyValueChangeOldKey</code></li><li>content ：用于标识KVO，移除特定的KVO</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AdHubKVOModel *testModel = [[AdHubKVOModel alloc]init];</div><div class="line">[testModel addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"keyPath"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div></pre></td></tr></table></figure><h2 id="触发回调"><a href="#触发回调" class="headerlink" title="触发回调"></a>触发回调</h2><p>设置 testModel.keyPath = @”20”;时会触发回调通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</div><div class="line">&#123;</div><div class="line">    // keyPath ：观察对象的属性</div><div class="line">    // object  ：被观察的对象</div><div class="line">    // change  ：包含 NSKeyValueChangeNewKey and NSKeyValueChangeOldKey</div><div class="line">                change[NSKeyValueChangeNewKey] / change[NSKeyValueChangeOldKey]</div><div class="line">    // context ：用于标识KVO，移除特定的KVO</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="自动通知"><a href="#自动通知" class="headerlink" title="自动通知"></a>自动通知</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Call the accessor method.</span></div><div class="line">[account setName:<span class="string">@"Savings"</span>];</div><div class="line"></div><div class="line"><span class="comment">// Use setValue:forKey:.</span></div><div class="line">[account setValue:<span class="string">@"Savings"</span> forKey:<span class="string">@"name"</span>];</div><div class="line"></div><div class="line"><span class="comment">// Use a key path, where 'account' is a kvc-compliant property of 'document'.</span></div><div class="line">[document setValue: <span class="string">@"Savings"</span> forKeyPath:<span class="string">@"account.name"</span>];</div><div class="line"></div><div class="line"><span class="comment">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span></div><div class="line">Transaction *newTransaction = &lt;<span class="meta">#Create a new transaction for the account#&gt;;</span></div><div class="line"><span class="built_in">NSMutableArray</span> *transactions = [account mutableArrayValueForKey:<span class="string">@"transactions"</span>];</div><div class="line">[transactions addObject:newTransaction];</div></pre></td></tr></table></figure><h2 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h2><p>需要重写<code>NSKeyValueObserving.h</code>中的方法, 判断当观察的 key 是 balance 时，就将自动通知关闭，其余的情况还是根据父类来进行判断<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</div><div class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">if</span> ([theKey isEqualToString:<span class="string">@"balance"</span>]) &#123;</div><div class="line">        automatic = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:theKey];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> automatic;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong> 返回YES时会自动调用 <code>-willChangeValueForKey:/-didChangeValueForKey:</code> 这两个方法；</strong><br><strong> 返回NO时需要手动设置 <code>-willChangeValueForKey:/-didChangeValueForKey:</code> 这两个方法。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</div><div class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</div><div class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">        _balance = theBalance;</div><div class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="同时设置多个属性值"><a href="#同时设置多个属性值" class="headerlink" title="同时设置多个属性值"></a>同时设置多个属性值</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"itemChanged"</span>];</div><div class="line">    _balance = theBalance;</div><div class="line">    _itemChanged = _itemChanged+<span class="number">1</span>;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"itemChanged"</span>];</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><h2 id="移除KVO"><a href="#移除KVO" class="headerlink" title="移除KVO"></a>移除KVO</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[observeredObject removeObserver:observer forKeyPath:keyPath];</div></pre></td></tr></table></figure><p>再次移除同一对象的同一属性会crash;</p><blockquote><p>Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘Cannot remove an observer <xxxxx 0x7f9310e0bec0=""> for the key path “keyPath” from <xxxx 0x600000648c70=""> because it is not registered as an observer.</xxxx></xxxxx></p></blockquote><p><strong> 移除KVO时， 注意：<code>forKeyPath</code>  传入 </strong></p><ul><li>不能为空</li><li>不能是观察对象中不存在的属性</li><li>不能是未被注册观察的属性<br>以上会造成crash：<blockquote><p><em>*</em> Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘-[__NSCFConstantString characterAtIndex:]: Range or index out of bounds</p></blockquote></li></ul><h1 id="原理是什么？"><a href="#原理是什么？" class="headerlink" title="原理是什么？"></a>原理是什么？</h1><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p><p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote><h2 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AdHubKVOModel *testModel = [[AdHubKVOModel alloc]init];</div></pre></td></tr></table></figure><p>打印 testModel 可以发现 :</p><blockquote><p>Printing description of testModel:<br><code>&lt;AdHubKVOModel: 0x60400044c390&gt;</code></p><p>Printing description of testModel:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="built_in">NSObject</span>) <span class="built_in">NSObject</span> = &#123;</div><div class="line">    isa = AdHubKVOModel</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>testModel 是AdHubKVOModel 的实例，其isa指针指向AdHubKVOModel</p></blockquote><h2 id="执行注册观察者的方法"><a href="#执行注册观察者的方法" class="headerlink" title="执行注册观察者的方法:"></a>执行注册观察者的方法:</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[testModel addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"keyPath"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</div></pre></td></tr></table></figure><p>再次打印 testModel 可以发现：</p><blockquote><p>Printing description of testModel:<br><code>&lt;AdHubKVOModel: 0x60400044c390&gt;</code></p><p>Printing description of testModel:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(NSObject) NSObject = &#123;</div><div class="line">    isa = NSKVONotifying_AdHubKVOModel</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>testModel 是 AdHubKVOModel 的实例，其isa指针却指向 <code>NSKVONotifying_AdHubKVOModel</code></p></blockquote><p><code>NSKVONotifying_AdHubKVOModel</code> 是什么？苹果的文档中提起对对象的属性注册观察者时，会对所观察的对象的isa指针进行修改，此时isa指针指向一个中间类，而不是一个真实的类，创建一个以<code>NSKVONotifying_</code>开头的的类名。<br>在这个类中，系统为我们重写了被观察属性的 setter 方法。</p><h2 id="KVO是如何寻找被观察属性的？"><a href="#KVO是如何寻找被观察属性的？" class="headerlink" title="KVO是如何寻找被观察属性的？"></a>KVO是如何寻找被观察属性的？</h2><ol><li>属性对象第一次被观察时，系统会自动生成一个以<code>NSKVONotifying_</code>开头的派生类，并在这个派生类中重写被观察属性的setter方法，在setter方法内实现通知回调机制。</li><li>每个对象都有一个isa指针指向对象所在类，当一个类对象被首次观察时，会将isa指针指向派生类，这点在上文中已经验证过，在派生类中的setter方法中真正的实现赋值。</li><li>在派生类中会实现两个方法: <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code>；<code>willChangeValueForKey:</code>记录旧的值，被观察对象的值改变后 <code>didChangeValueForKey:</code> 被调用， <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。</li><li>如果在当前类中未找到要监测的属性，则会向当前类的父类中查找。。。一直找下去，找到执行第一步。没有找到，则不会触发通知回调。</li></ol><h2 id="限制条件是什么？"><a href="#限制条件是什么？" class="headerlink" title="限制条件是什么？"></a>限制条件是什么？</h2><h3 id="猜想一：-forKeyPath-为实例对象是否可以？"><a href="#猜想一：-forKeyPath-为实例对象是否可以？" class="headerlink" title="猜想一： forKeyPath 为实例对象是否可以？"></a><em>猜想一： forKeyPath 为实例对象是否可以？</em></h3><p>可以，但KVO不会触发回调通知。</p><h3 id="猜想二：如果手动为实例对象创建一个setter方法是否可以？"><a href="#猜想二：如果手动为实例对象创建一个setter方法是否可以？" class="headerlink" title="猜想二：如果手动为实例对象创建一个setter方法是否可以？"></a><em>猜想二：如果手动为实例对象创建一个setter方法是否可以？</em></h3><p>没错，是可以的，因为KVO监测的是被监测对象属性的setter方法。</p><h3 id="猜想三：forKeyPath-为空-nil-时是否可以？"><a href="#猜想三：forKeyPath-为空-nil-时是否可以？" class="headerlink" title="猜想三：forKeyPath 为空 / nil 时是否可以？"></a><em>猜想三：forKeyPath 为空 / nil 时是否可以？</em></h3><p>会造成crash：</p><blockquote><p><em>*</em> Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘-[__NSCFConstantString characterAtIndex:]: Range or index out of bounds</p></blockquote><h3 id="猜想四：-forKeyPath-为不存在的实例对象是否可以？"><a href="#猜想四：-forKeyPath-为不存在的实例对象是否可以？" class="headerlink" title="猜想四： forKeyPath 为不存在的实例对象是否可以？"></a><em>猜想四： forKeyPath 为不存在的实例对象是否可以？</em></h3><p>可以，但KVO不会触发回调通知。</p><h3 id="猜想五：-forKeyPath-为方法名是否可以？"><a href="#猜想五：-forKeyPath-为方法名是否可以？" class="headerlink" title="猜想五： forKeyPath 为方法名是否可以？"></a><em>猜想五： forKeyPath 为方法名是否可以？</em></h3><p>可以，但KVO不会触发回调通知。</p><h3 id="猜想六：-同一个类中注册多个KVO会怎么样？"><a href="#猜想六：-同一个类中注册多个KVO会怎么样？" class="headerlink" title="猜想六： 同一个类中注册多个KVO会怎么样？"></a><em>猜想六： 同一个类中注册多个KVO会怎么样？</em></h3><p>所有的回调都是走同一个回调方法，需要对触发回调函数的来源进行判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</div><div class="line">&#123;</div><div class="line">    // keyPath ：观察对象的属性, 可用于判断触发回调函数的来源</div><div class="line">    // object  ：被观察的对象</div><div class="line">    // change  ：包含 NSKeyValueChangeNewKey and NSKeyValueChangeOldKey</div><div class="line">    // context ：用于标识KVO，移除特定的KVO</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="猜想七：-被观察类的父类中也实现了KVO会怎么样？"><a href="#猜想七：-被观察类的父类中也实现了KVO会怎么样？" class="headerlink" title="猜想七： 被观察类的父类中也实现了KVO会怎么样？"></a><em>猜想七： 被观察类的父类中也实现了KVO会怎么样？</em></h3><p>比如被观察类A，其父类为superA，superA中也实现了KVO，那么在C类中添加对A类的某个属性的观察，会怎么样？<br>被观察属性值都发生变化，先走C类中的回调方法，然后在走superA类中的回调方法。</p><h2 id="模拟实现系统KVO"><a href="#模拟实现系统KVO" class="headerlink" title="模拟实现系统KVO"></a>模拟实现系统KVO</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是KVO&quot;&gt;&lt;a href=&quot;#什么是KVO&quot; class=&quot;headerlink&quot; title=&quot;什么是KVO?&quot;&gt;&lt;/a&gt;什么是KVO?&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Key-value observing is a mechanism that
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="KV_X" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/KV-X/"/>
    
      <category term="KVO" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/KV-X/KVO/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>KVC</title>
    <link href="https://github.com/songMW/stack.github.io/2017/06/14/Objective-C/KV_X/KVC/"/>
    <id>https://github.com/songMW/stack.github.io/2017/06/14/Objective-C/KV_X/KVC/</id>
    <published>2017-06-14T03:05:05.000Z</published>
    <updated>2018-01-18T11:03:54.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSKeyValueCoding简介"><a href="#NSKeyValueCoding简介" class="headerlink" title="NSKeyValueCoding简介"></a>NSKeyValueCoding简介</h2><blockquote><p>A mechanism by which you can access the properties of an object indirectly by name or key。</p></blockquote><ol><li>KVC 是 Key-Value-Coding 的简称， 是一种间接访问对象属性的机制;</li><li>KVC 是通过字符串的名字 [key] 来访问类属性的机制, 而不是通过调用 setter、getter 方法去访问；</li><li>KVC 是通过名称（键）简介访问和操作对象的属性；</li><li>KVC 的键是属性的名称，值是属性的值。</li></ol><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>对象的内部状态是由属性封装，该状态无法直接读取，需要使用属性的访问方法：setter和getter；编译器会自动生成setter和getter方法，减少手动编写的代码量并提高了程序的一致性和可维护性。</p><h3 id="如何获取对象的属性"><a href="#如何获取对象的属性" class="headerlink" title="如何获取对象的属性"></a>如何获取对象的属性</h3><ol><li>使用标准的属性访问方法访问该属性；</li><li>使用点语法访问，编译器会自动将属性的点表达式转换为对应的调用访问方法的语句 -&gt; 标准的属性访问方法。</li></ol><h3 id="使用标准属性访问方法更新模型"><a href="#使用标准属性访问方法更新模型" class="headerlink" title="使用标准属性访问方法更新模型"></a>使用标准属性访问方法更新模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)updateModel:(NSString *)value forKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if ([key isEqualToStirng:@&quot;age&quot;]) &#123;</div><div class="line">        self.age = value;</div><div class="line">    &#125;</div><div class="line">    if ([key isEqualToStirng:@&quot;name&quot;]) &#123;</div><div class="line">        self.name = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每次属性的值发生改变时都需要调用这段代码来更新新值，不具备良好的伸缩性且难以维护。</p><h3 id="使用键值编码更新模型"><a href="#使用键值编码更新模型" class="headerlink" title="使用键值编码更新模型"></a>使用键值编码更新模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)updateModel:(NSString *)value forKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    [self setValue: value forKey: key];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码量少了很多，易于维护和拓展，当模型中的属性发生变化时，无须逐个去更新模型值。</p><h2 id="键和键路径"><a href="#键和键路径" class="headerlink" title="键和键路径"></a>键和键路径</h2><ol><li>键是用于标识属性的字符串；</li><li>键路径指明了需要遍历的对象的属性序列。</li></ol><h3 id="使用KVC获取多个属性的值"><a href="#使用KVC获取多个属性的值" class="headerlink" title="使用KVC获取多个属性的值"></a>使用KVC获取多个属性的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;name&quot;, @&quot;age&quot;];</div><div class="line">NSDictionary *dict = [person dictionaryWithValuesForKeys:array];</div></pre></td></tr></table></figure><p>这里的 <code>name</code> 和 <code>age</code> 属性都是 <code>person</code> 类的实例。</p><h3 id="使用KVC设置多个属性值"><a href="#使用KVC设置多个属性值" class="headerlink" title="使用KVC设置多个属性值"></a>使用KVC设置多个属性值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name *tom = [[Name alloc]init];</div><div class="line">Address *home = [[Address alloc]init];</div><div class="line">NSDictionary *personProperties = @&#123;@&quot;name&quot; : tom, @&quot;address&quot; : home&#125;;</div><div class="line">[person setValuesForKeysWithDictionary:personProperties];</div></pre></td></tr></table></figure><p>这里只要是  <code>person</code> 类中的实例都可以去设置，因为KVC可以遍历键路径。 简单的说就是 <code>person.zone...</code> 这样的形式。</p><h2 id="实现KVC"><a href="#实现KVC" class="headerlink" title="实现KVC"></a>实现KVC</h2><p>键值编码的设计基于以下两种基本的机制：</p><ol><li>通过名称/键间接访问对象的属性，而不是直接调用访问方法；</li><li>将键与属性访问方法或属性支持的变量对应起来。</li></ol><p>非正式协议 <code>NSKeyValueCoding</code> 定义了通过名称/键间接访问对象属性的机制。<code>NSObject</code> 类遵循  <code>NSKeyValueCoding</code>  协议，因此它的所有类都为键值编码提供支持。</p><h3 id="键值编码API"><a href="#键值编码API" class="headerlink" title="键值编码API"></a>键值编码API</h3><p>非正式协议 <code>NSKeyValueCoding</code> 定义了标准的键值编码API，这些方法可以获取/设置属性值，属性验证及配置键值编码操作。</p><h4 id="accessInstanceVariablesDirectly"><a href="#accessInstanceVariablesDirectly" class="headerlink" title="accessInstanceVariablesDirectly"></a><code>accessInstanceVariablesDirectly</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)accessInstanceVariablesDirectly;</div></pre></td></tr></table></figure><p>该方法返回一个BOOL值， YES表示键值编码可以直接访问相应的实例变量，NO表示不能只能搜索 <code>set&lt;key&gt;</code>的名称。<br>默认返回YES，可以重写该方法。</p><h4 id="valueForUndefinedKey"><a href="#valueForUndefinedKey" class="headerlink" title="valueForUndefinedKey"></a><code>valueForUndefinedKey</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)valueForUndefinedKey:(NSString *)key;</div></pre></td></tr></table></figure><p>当 <code>valueForKey:</code> 方法发现没有与输入的键对应的时候会调用。<br>未定义键方法的默认实现会抛出<code>NSUndefinedKeyException</code>异常，可以在子类中重写使未定义键返回自定义值。</p><h4 id="setValue-forUndefinedKey"><a href="#setValue-forUndefinedKey" class="headerlink" title="setValue:forUndefinedKey:"></a><code>setValue:forUndefinedKey:</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div></pre></td></tr></table></figure><p>当 <code>setValue:forKey:</code> 方法发现没有与输入的键对应的时候会调用。<br>未定义键方法的默认实现会抛出<code>NSUndefinedKeyException</code>异常，可以在子类中重写使未定义键返回自定义值。</p><h4 id="valueForUndefinedKey：方法的实现"><a href="#valueForUndefinedKey：方法的实现" class="headerlink" title="valueForUndefinedKey：方法的实现"></a>valueForUndefinedKey：方法的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)valueForUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if (nil == key &amp;&amp; [@&quot;hello&quot; isEqualToString: key]) &#123;</div><div class="line">        return 自定义值；</div><div class="line">    &#125;</div><div class="line">    // 抛出异常</div><div class="line">    [NSException raise: NSUndefinedKeyException format: @&quot;key %@ not defined&quot;, key];</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="setNilValueForKey-NSString-key"><a href="#setNilValueForKey-NSString-key" class="headerlink" title="setNilValueForKey:(NSString *)key"></a><code>setNilValueForKey:(NSString *)key</code></h4><p>如果设置的属性是基本数据类型时，不能<code>setValue:nil</code> ，会crash。需要重写这个方法。</p><h4 id="validateValue-forKey-error"><a href="#validateValue-forKey-error" class="headerlink" title="validateValue:forKey:error:"></a><code>validateValue:forKey:error:</code></h4><p>它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p><h4 id="validateValue-forKeyPath-error"><a href="#validateValue-forKeyPath-error" class="headerlink" title="validateValue:forKeyPath:error"></a><code>validateValue:forKeyPath:error</code></h4><h4 id="集合返回可变实例"><a href="#集合返回可变实例" class="headerlink" title="集合返回可变实例"></a>集合返回可变实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *items = [order mutaleArrayValueForKey:@&quot;items&quot;];</div></pre></td></tr></table></figure><p>即使是只读集合，也可以返回可变集合实例。</p><h3 id="键值搜索-setValue-forKey-调用顺序"><a href="#键值搜索-setValue-forKey-调用顺序" class="headerlink" title="键值搜索 setValue:forKey: 调用顺序"></a>键值搜索 <code>setValue:forKey:</code> 调用顺序</h3><ol><li>搜索目标类寻找名称符合格式 <code>set&lt;Key&gt;:</code> ，<code>setIs&lt;Key&gt;:</code> 的访问方法，<code>key</code>是属性名称；比如：key = “name”，KVC在目标类中搜索名为<code>setName:</code>的访问方法；</li><li>如果没有搜索到访问方法，<code>accessInstanceVariablesDirectly</code> 返回YES，就会在目标类中搜索名称为 <code>_&lt;key&gt;</code>，<code>_is&lt;Key&gt;</code>，<code>&lt;key&gt;</code>，<code>is&lt;Key&gt;</code> 格式的实例变量。注：搜索优先级从高到低。</li><li>如果找到了匹配的访问方法或者实例变量，<code>setValue:forKey:</code>  就会被用于设置值；</li><li>如果没有找到匹配的访问方法或实例变量，接收对象 <code>setValue:forUndefinedKey:</code> 会被调用。</li></ol><p>代码验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#import &quot;HBBaseModel.h&quot;</div><div class="line"></div><div class="line">@interface KVCModel : HBBaseModel</div><div class="line">&#123;</div><div class="line">    NSString *_name;</div><div class="line">    NSString *_isName;</div><div class="line">    NSString *name;</div><div class="line">    NSString *isName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setName:(NSString *)newName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation KVCModel</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _name = @&quot;_name&quot;;</div><div class="line">        _isName = @&quot;_isName&quot;;</div><div class="line">        name = @&quot;name&quot;;</div><div class="line">        isName = @&quot;isName&quot;;</div><div class="line">&#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 1. 有set&lt;Key&gt;, 此时打印结果只有 _name 和 _isName 的值改变为 newName</div><div class="line">- (void)setName:(NSString *)newName</div><div class="line">&#123;</div><div class="line">    _name = newName;</div><div class="line">    _isName = newName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2. 如果注释掉 set&lt;Key&gt;， 会去调用 accessInstanceVariablesDirectly， 如果返回YES时会去查找实例变量，执行 3-6步；返回NO，则不会去查找实例变量，执行第8步。</div><div class="line"></div><div class="line">// 3. 注释掉set&lt;Key&gt;, 此时只有 _name 的值改变为设置的新值；</div><div class="line">// 4. 注释掉 _name, 此时只有 _isName 的值改变为设置的新值；</div><div class="line">// 5. 注释掉_isName, 此时只有 name 的值改变为设置的新值；</div><div class="line">// 6. 注释掉 name, 此时只有 isName 的值改变为设置的新值；</div><div class="line">// 7. 如果没有查找到上述相关的KEY，则会执行第8步。</div><div class="line"></div><div class="line">// 8. 都没有查找到对应KEY则会调用 setValue:forUndefinedKey:</div><div class="line"></div><div class="line">- (NSString *)HB_description</div><div class="line">&#123;</div><div class="line">    NSString *des = [NSString stringWithFormat:@&quot;\n_name:%@\n_isName:%@\nname:%@\nisName:%@&quot;, _name, _isName, name, isName];</div><div class="line">    NSLog(@&quot;=====================PRINT BEGIN=====================&quot;);</div><div class="line">    NSLog(@&quot;%@&quot;, des);</div><div class="line">    NSLog(@&quot;=====================PRINT END=======================&quot;);</div><div class="line">    return des;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="键值搜索-valueForKey-调用顺序"><a href="#键值搜索-valueForKey-调用顺序" class="headerlink" title="键值搜索 valueForKey: 调用顺序"></a>键值搜索 <code>valueForKey:</code> 调用顺序</h3><ol><li>获取方法的名称<key>访问方法格式，<code>get&lt;Key&gt;</code>，<code>&lt;key&gt;</code>，<code>is&lt;Key&gt;</code>。注：搜索优先级从高到低。</key></li><li>如果没有搜索到访问方法，会去搜索<code>countOf&lt;Key&gt;</code> 和 <code>objectIn&lt;key&gt;AtIndex:(&lt;Key&gt;AtIndexes:)</code>这两个方法，一般很少用；</li><li>如果没有搜索到上述方法，<code>accessInstanceVariablesDirectly</code> 返回YES，就会在目标类中搜索名称为  <code>_&lt;key&gt;</code> 格式的实例变量。注：网上有些教程说没有找到 <code>_&lt;key&gt;</code> 会按 <code>_is&lt;Key&gt;</code>，<code>&lt;key&gt;</code>，<code>is&lt;Key&gt;</code>  的顺序依次去查询，代码验证的时候发现 <code>_is&lt;Key&gt;</code>，<code>&lt;key&gt;</code>，<code>is&lt;Key&gt;</code>  返回都是null。</li><li>如果找到了匹配的访问方法或者实例变量，<code>valueForKey:</code>  就会被用于获取值；</li><li>如果没有找到匹配的访问方法或实例变量，接收对象 <code>valueForUndefinedKey:</code> 会被调用。</li></ol><p>代码验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">#import &quot;KVCModel.h&quot;</div><div class="line"></div><div class="line">@interface KVCModel()</div><div class="line"></div><div class="line">@property (nonatomic,strong)NSMutableArray *dataArray;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation KVCModel</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _name = @&quot;_name&quot;;</div><div class="line">        _isName = @&quot;_isName&quot;;</div><div class="line">        name = @&quot;name&quot;;</div><div class="line">        isName = @&quot;isName&quot;;</div><div class="line"></div><div class="line">        _dataArray = [NSMutableArray array];</div><div class="line">        [_dataArray addObject:_name];</div><div class="line">        [_dataArray addObject:_isName];</div><div class="line">        [_dataArray addObject:name];</div><div class="line">        [_dataArray addObject:isName];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 1. 首先查找 get&lt;Key&gt;</div><div class="line">- (NSString *)getName</div><div class="line">&#123;</div><div class="line">    return @&quot;getName&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2. 其次查找 &lt;key&gt;</div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">    return @&quot;name&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 3. 然后是is&lt;Key&gt;</div><div class="line">- (NSString *)isName</div><div class="line">&#123;</div><div class="line">    return @&quot;isName&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果1，2，3都没有查找到</div><div class="line">// 4. 查找countOf&lt;Key&gt;</div><div class="line">- (NSUInteger)countOfName</div><div class="line">&#123;</div><div class="line">    return self.dataArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (KVCModel *)objectInNameAtIndex:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    return [self.dataArray objectAtIndex:index];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果1，2，3，4都没有，查找accessInstanceVariablesDirectly</div><div class="line">// 如果accessInstanceVariablesDirectly返回YES；</div><div class="line">查找_&lt;key&gt;格式的实例变量；没有该格式的变量时会执行第8步。</div><div class="line">// 如果accessInstanceVariablesDirectly返回NO, 执行第8步</div><div class="line"></div><div class="line">// 8. 抛出异常</div><div class="line">- (id)valueForUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    return @&quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="自定义KVC"><a href="#自定义KVC" class="headerlink" title="自定义KVC"></a>自定义KVC</h3><h4 id="实现-setValue-forKey"><a href="#实现-setValue-forKey" class="headerlink" title="实现 setValue:forKey:"></a>实现 <code>setValue:forKey:</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">- (void)HB_setValue:(id)value forKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    if (!key.length || !key) &#123;</div><div class="line">        NSException *exception = [NSException exceptionWithName:@&quot;HBKeyValueCoding&quot; reason:[NSString stringWithFormat:@&quot;key:%@ is not exist!&quot;, key] userInfo:nil];</div><div class="line">        @throw exception;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // find set&lt;Key&gt;</div><div class="line">    NSString *setKey = [NSString stringWithFormat:@&quot;set%@:&quot;, key.capitalizedString];</div><div class="line">    if ([self respondsToSelector:NSSelectorFromString(setKey)]) &#123;</div><div class="line">        HBSuppressPerformSelectorLeakWarning(</div><div class="line">            [self performSelector:NSSelectorFromString(setKey) withObject:value];</div><div class="line">        )</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // find setIs&lt;Key&gt;</div><div class="line">    NSString *setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;,key.capitalizedString];</div><div class="line">    if ([self respondsToSelector:NSSelectorFromString(setIsKey)]) &#123;</div><div class="line">        HBSuppressPerformSelectorLeakWarning(</div><div class="line">            [self performSelector:NSSelectorFromString(setIsKey) withObject:value];</div><div class="line">        )</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // if set&lt;Key&gt; and setIs&lt;Key&gt; is not exist</div><div class="line">    BOOL result = [self.class accessInstanceVariablesDirectly];</div><div class="line">    if (!result) &#123;</div><div class="line">        NSException *exception = [NSException exceptionWithName:@&quot;HBKeyValueCoding&quot; reason:@&quot;accessInstanceVariablesDirectly return NO!&quot; userInfo:nil];</div><div class="line">        @throw exception;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // if accessInstanceVariablesDirectly return YES, find current class variables.</div><div class="line">    NSArray *varLists = [self HB_accessCurrenClassVariables];</div><div class="line"></div><div class="line">    // _&lt;key&gt;</div><div class="line">    NSString *keyName = [NSString stringWithFormat:@&quot;_%@&quot;, key];</div><div class="line">    if ([varLists containsObject:keyName]) &#123;</div><div class="line">        Ivar var = class_getInstanceVariable(self.class, keyName.UTF8String);</div><div class="line">        object_setIvar(self, var, value);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // _is&lt;Key&gt;</div><div class="line">    keyName = [NSString stringWithFormat:@&quot;_is%@&quot;, key.capitalizedString];</div><div class="line">    if ([varLists containsObject:keyName]) &#123;</div><div class="line">        Ivar var = class_getInstanceVariable(self.class, keyName.UTF8String);</div><div class="line">        object_setIvar(self, var, value);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // &lt;key&gt;</div><div class="line">    keyName = key;</div><div class="line">    if ([varLists containsObject:keyName]) &#123;</div><div class="line">        object_setIvar(selIvar var = class_getInstanceVariable(self.class, keyName.UTF8String);</div><div class="line">        object_setIvar(self, var, value);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //is&lt;Key&gt;</div><div class="line">    keyName = [NSString stringWithFormat:@&quot;is%@&quot;, key.capitalizedString];</div><div class="line">    if ([varLists containsObject:keyName]) &#123;</div><div class="line">        Ivar var = class_getInstanceVariable(self.class, keyName.UTF8String);</div><div class="line">        object_setIvar(self, var, value);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // deal with exception</div><div class="line">    [self setValue:value forUndefinedKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;\n ==================== IMPORTANT ====================&quot;);</div><div class="line">    NSLog(@&quot;Class:%@ UndefinedKey: %@&quot;, NSStringFromClass(self.class), key);</div><div class="line">    NSLog(@&quot;==================== IMPORTANT ====================&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="实现-valueForKey"><a href="#实现-valueForKey" class="headerlink" title="实现 valueForKey:"></a>实现 <code>valueForKey:</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">- (NSString *)HB_valueForKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    NSString *value = @&quot;&quot;;</div><div class="line">    if (!key.length || !key) &#123;</div><div class="line">        NSException *exception = [NSException exceptionWithName:@&quot;HBKeyValueCoding&quot; reason:[NSString stringWithFormat:@&quot;key:%@ is not exist!&quot;, key] userInfo:nil];</div><div class="line">        @throw exception;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // find get&lt;Key&gt;</div><div class="line">    NSString *getKey = [NSString stringWithFormat:@&quot;get%@&quot;, key.capitalizedString];</div><div class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</div><div class="line">        HBSuppressPerformSelectorLeakWarning(</div><div class="line">            value = [self performSelector:NSSelectorFromString(getKey)];</div><div class="line">        )</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // if get&lt;Key&gt; not exist, find &lt;key&gt;</div><div class="line">    if ([self respondsToSelector:NSSelectorFromString(key)]) &#123;</div><div class="line">        HBSuppressPerformSelectorLeakWarning(</div><div class="line">            value = [self performSelector:NSSelectorFromString(key)];</div><div class="line">        )</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // if &lt;key&gt; not exist, find is&lt;Key&gt;</div><div class="line">    NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;, key.capitalizedString];</div><div class="line">    if ([self respondsToSelector:NSSelectorFromString(isKey)]) &#123;</div><div class="line">        HBSuppressPerformSelectorLeakWarning(</div><div class="line">            value = [self performSelector:NSSelectorFromString(isKey)];</div><div class="line">        )</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // find accessInstanceVariablesDirectly.</div><div class="line">    BOOL result = [self.class accessInstanceVariablesDirectly];</div><div class="line">    if (!result) &#123;</div><div class="line">        NSException *exception = [NSException exceptionWithName:@&quot;HBKeyValueCoding&quot; reason:@&quot;accessInstanceVariablesDirectly return NO&quot; userInfo:nil];</div><div class="line">        @throw exception;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSArray *varLists = [self HB_accessCurrenClassVariables];</div><div class="line">    NSString *keyName = key;</div><div class="line">    NSString *fisrtChar = [key substringToIndex:1];</div><div class="line">    if (![fisrtChar isEqualToString:@&quot;_&quot;]) &#123;</div><div class="line">        keyName = [NSString stringWithFormat:@&quot;_%@&quot;, key];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if ([varLists containsObject:keyName]) &#123;</div><div class="line">        Ivar var = class_getInstanceVariable(self.class, keyName.UTF8String);</div><div class="line">        id varValue = object_getIvar(self, var);</div><div class="line">        value = [NSString stringWithFormat:@&quot;%@&quot;, varValue];</div><div class="line">         return value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 异常处理</div><div class="line">    [self valueForUndefinedKey:key];</div><div class="line">    return value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)valueForUndefinedKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;\n ==================== IMPORTANT ====================&quot;);</div><div class="line">    NSLog(@&quot;Class:%@ valueForUndefinedKey: %@&quot;, NSStringFromClass(self.class), key);</div><div class="line">    NSLog(@&quot;==================== IMPORTANT ====================&quot;);</div><div class="line">    return @&quot;没有匹配到相关key:我也很为难！&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上是模拟KVC的实现方式，其中添加了容错处理，更容易去定位。日常开发中使用KVC用系统的就可以，手动实现 <code>valueForUndefinedKey</code> 和 <code>setValue: forUndefinedKey:</code> 即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NSKeyValueCoding简介&quot;&gt;&lt;a href=&quot;#NSKeyValueCoding简介&quot; class=&quot;headerlink&quot; title=&quot;NSKeyValueCoding简介&quot;&gt;&lt;/a&gt;NSKeyValueCoding简介&lt;/h2&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="KV_X" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/KV-X/"/>
    
      <category term="KVC" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/KV-X/KVC/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Clang</title>
    <link href="https://github.com/songMW/stack.github.io/2017/05/15/Objective-C/Decompilation/Clang/"/>
    <id>https://github.com/songMW/stack.github.io/2017/05/15/Objective-C/Decompilation/Clang/</id>
    <published>2017-05-15T07:47:07.000Z</published>
    <updated>2018-01-02T08:55:30.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Clang是什么？"><a href="#Clang是什么？" class="headerlink" title="Clang是什么？"></a>Clang是什么？</h2><p><code>Clang是一个C、C++、OC语言的轻量级编译器.</code></p><h2 id="Clang的用途-重写OC源码转为C"><a href="#Clang的用途-重写OC源码转为C" class="headerlink" title="Clang的用途 重写OC源码转为C++"></a>Clang的用途 重写OC源码转为C++</h2><p><code>clang -rewrite-objc xxx.m</code> 遇到如下的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">main.m:9:9: fatal error: &apos;UIKit/UIKit.h&apos; file not found</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">^</div><div class="line">1 error generated.</div></pre></td></tr></table></figure></p><p>解决方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xxx.m</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Clang是什么？&quot;&gt;&lt;a href=&quot;#Clang是什么？&quot; class=&quot;headerlink&quot; title=&quot;Clang是什么？&quot;&gt;&lt;/a&gt;Clang是什么？&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Clang是一个C、C++、OC语言的轻量级编译器.&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="Decompilation" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/Decompilation/"/>
    
      <category term="Clang" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/Decompilation/Clang/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>load</title>
    <link href="https://github.com/songMW/stack.github.io/2017/05/04/Objective-C/load/"/>
    <id>https://github.com/songMW/stack.github.io/2017/05/04/Objective-C/load/</id>
    <published>2017-05-04T08:20:45.000Z</published>
    <updated>2018-01-16T10:40:30.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-load-是什么"><a href="#1-load-是什么" class="headerlink" title="1. load 是什么?"></a>1. load 是什么?</h2><ul><li>定义在NSObject.h头文件中</li><li>load方法在这个文件被程序装载时调用, 只要是在Compile Sources中出现的文件总是会被装载, 无论这个类是否被用到;</li><li>load方法在main函数之前调用;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (void)load; </div><div class="line"></div><div class="line">3. +[class load]</div><div class="line">2. call_load_methods</div><div class="line">1. _dyld_start</div></pre></td></tr></table></figure><h2 id="2-load-怎么调用"><a href="#2-load-怎么调用" class="headerlink" title="2. load 怎么调用?"></a>2. load 怎么调用?</h2><ul><li>如果在一个类中实现 load 方法, 则会先调用其父类的 load 方法, 是系统自动调用的; </li><li>如果一个类没有实现 load 方法, 则系统不会调用它的父类;</li><li>类别中调用 load 方法, 遵循上面两条;</li><li>load 方法不能手动调用;</li><li>load 是线程安全的, 内部使用了锁, 应该避免在 load 中阻塞线程</li></ul><h2 id="3-load-使用场景"><a href="#3-load-使用场景" class="headerlink" title="3. load 使用场景"></a>3. load 使用场景</h2><ul><li>实现 Method Swizzle <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (void)load&#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Method originalDealloc = class_getInstanceMethod(self, NSSelectorFromString(@&quot;dealloc&quot;));</div><div class="line">        Method newDealloc = class_getInstanceMethod(self, @selector(autoRemoveObserverDealloc));</div><div class="line">        method_exchangeImplementations(originalDealloc, newDealloc);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="4-源码学习"><a href="#4-源码学习" class="headerlink" title="4. 源码学习"></a>4. 源码学习</h2><h2 id="objc—-gt-Sources—-gt-objc-loadmethod-mm"><a href="#objc—-gt-Sources—-gt-objc-loadmethod-mm" class="headerlink" title="objc—&gt;Sources—&gt;objc-loadmethod.mm"></a>objc—&gt;Sources—&gt;objc-loadmethod.mm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">struct loadable_class &#123;</div><div class="line">    Class cls;  // may be nil</div><div class="line">    IMP method;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct loadable_category &#123;</div><div class="line">    Category cat;  // may be nil</div><div class="line">    IMP method;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// List of classes that need +load called (pending superclass +load)</div><div class="line">// This list always has superclasses first because of the way it is constructed</div><div class="line">static struct loadable_class *loadable_classes = nil;</div><div class="line">static int loadable_classes_used = 0;</div><div class="line">static int loadable_classes_allocated = 0;</div><div class="line"></div><div class="line">// List of categories that need +load called (pending parent class +load)</div><div class="line">static struct loadable_category *loadable_categories = nil;</div><div class="line">static int loadable_categories_used = 0;</div><div class="line">static int loadable_categories_allocated = 0;</div></pre></td></tr></table></figure><h3 id="这段代码介绍两个结构体指针-分别是可承载的类和类别-类中"><a href="#这段代码介绍两个结构体指针-分别是可承载的类和类别-类中" class="headerlink" title="这段代码介绍两个结构体指针, 分别是可承载的类和类别. 类中"></a>这段代码介绍两个结构体指针, 分别是可承载的类和类别. 类中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* add_class_to_loadable_list</div><div class="line">* Class cls has just become connected. Schedule it for +load if</div><div class="line">* it implements a +load method.</div><div class="line">**********************************************************************/</div><div class="line">void add_class_to_loadable_list(Class cls)</div><div class="line">&#123;</div><div class="line">    IMP method;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    method = cls-&gt;getLoadMethod();</div><div class="line">    if (!method) return;  // Don&apos;t bother if cls has no +load method</div><div class="line"></div><div class="line">    if (PrintLoading) &#123;</div><div class="line">        _objc_inform(&quot;LOAD: class &apos;%s&apos; scheduled for +load&quot;, </div><div class="line">        cls-&gt;nameForLogging());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (loadable_classes_used == loadable_classes_allocated) &#123;</div><div class="line">        loadable_classes_allocated = loadable_classes_allocated*2 + 16;</div><div class="line">        loadable_classes = (struct loadable_class *)</div><div class="line">        realloc(loadable_classes,</div><div class="line">        loadable_classes_allocated *</div><div class="line">        sizeof(struct loadable_class));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loadable_classes[loadable_classes_used].cls = cls;</div><div class="line">    loadable_classes[loadable_classes_used].method = method;</div><div class="line">    loadable_classes_used++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-声明一个IMP"><a href="#1-声明一个IMP" class="headerlink" title="1. 声明一个IMP;"></a>1. 声明一个IMP;</h3><h3 id="2-loadMethodLock-assertLocked-线程安全-使用recursive-mutex-t上锁"><a href="#2-loadMethodLock-assertLocked-线程安全-使用recursive-mutex-t上锁" class="headerlink" title="2. loadMethodLock.assertLocked(); 线程安全, 使用recursive_mutex_t上锁"></a>2. <code>loadMethodLock.assertLocked();</code> 线程安全, 使用recursive_mutex_t上锁</h3><h3 id="3-cls-gt-getLoadMethod-这个方法是获取一个类声明的-load-方法-如果没有声明-load-则会返回nil"><a href="#3-cls-gt-getLoadMethod-这个方法是获取一个类声明的-load-方法-如果没有声明-load-则会返回nil" class="headerlink" title="3. cls-&gt;getLoadMethod()这个方法是获取一个类声明的 +load 方法, 如果没有声明 +load 则会返回nil;"></a>3. <code>cls-&gt;getLoadMethod()</code>这个方法是获取一个类声明的 <code>+load</code> 方法, 如果没有声明 <code>+load</code> 则会返回nil;</h3><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void prepare_load_methods(const headerType *mhdr)</div><div class="line">&#123;</div><div class="line">    size_t count, i;</div><div class="line">    runtimeLock.assertWriting();</div><div class="line">    classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</div><div class="line">    for (i = 0; i &lt; count; i++) &#123;</div><div class="line">        schedule_class_load(remapClass(classlist[i]));</div><div class="line">    &#125;</div><div class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</div><div class="line">    for (i = 0; i &lt; count; i++) &#123;</div><div class="line">        category_t *cat = categorylist[i];</div><div class="line">        Class cls = remapClass(cat-&gt;cls);</div><div class="line">        if (!cls) continue;  // category for ignored weak-linked class</div><div class="line">        realizeClass(cls);</div><div class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</div><div class="line">        add_category_to_loadable_list(cat);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="1-headerType-是什么"><a href="#1-headerType-是什么" class="headerlink" title="1.  headerType  是什么?"></a>1. <em> headerType </em> 是什么?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct mach_header headerType;</div><div class="line">/*</div><div class="line">* The 32-bit mach header appears at the very beginning of the object file for</div><div class="line">* 32-bit architectures.</div><div class="line">*/</div><div class="line">struct mach_header &#123;</div><div class="line">    uint32_tmagic;/* mach magic number identifier */</div><div class="line">    cpu_type_tcputype;/* cpu specifier */</div><div class="line">    cpu_subtype_tcpusubtype;/* machine specifier */</div><div class="line">    uint32_tfiletype;/* type of file */</div><div class="line">    uint32_tncmds;/* number of load commands */</div><div class="line">    uint32_tsizeofcmds;/* the size of all the load commands */</div><div class="line">    uint32_tflags;/* flags */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-load-是什么&quot;&gt;&lt;a href=&quot;#1-load-是什么&quot; class=&quot;headerlink&quot; title=&quot;1. load 是什么?&quot;&gt;&lt;/a&gt;1. load 是什么?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;定义在NSObject.h头文件中&lt;/li&gt;
&lt;li&gt;l
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="KnowledgeLists" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/"/>
    
      <category term="load" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/KnowledgeLists/load/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>arm指令集错误收集</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/26/Objective-C/CrashCollection/arm%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/26/Objective-C/CrashCollection/arm指令集/</id>
    <published>2017-04-26T08:48:52.000Z</published>
    <updated>2018-01-02T08:52:11.960Z</updated>
    
    <content type="html"><![CDATA[<p>iOS的指令集有 <code>armv6、armv7、armv7s、arm64</code> Arm是向下兼容的</p><ol><li>armv6 <ul><li>iPhone</li><li>iPhone2</li><li>iPhone3G</li><li>iPod Touch(1, 2)</li></ul></li><li>armv7 <ul><li>iPhone4</li><li>iPhone4S</li><li>iPod (3G, 4G, 5G)</li><li>iPad(1, 2 , 3 , Mini)</li></ul></li><li>armv7s<ul><li>iPhone5</li><li>iPhone5C</li><li>iPad 4</li></ul></li><li>arm64 <ul><li>iPhone5S以后</li><li>iPad Air(2), Retina iPad Mini(2,3)</li></ul></li><li>Architecture: 指你想支持的指令集</li><li>Valid architectures: 指即将编译的指令集</li><li>Build Active Architecture Only: 是否只编译当前适用的指令集 <ul><li>如果要app在各个机器都能够最高效率的运行, 需要将Build Active Architecture Only改为 NO, Valid architectures选择对应的指令集: armv7 armv7s arm64; 但是编译后包得体积会增加, Release时必须设置为NO; </li><li>Valid architectures 为 armv7 时包的体积最小(不能编译armv6), Build Active Architectures 任意;</li><li>如果Build Active Architecture Only设置为 YES, 那么用iPhone 6调试, 最终生成的一个支持arm64指令集的Binary;使用iPhone4编译, 最终生成一个支持armv7指令集的Binary; 意思是只会编译对应指令的包; </li><li>如果Build Active Architecture Only设置为 NO, 编译器会整合指令集, 包会变大, 可以设配不同的设备; 所以一般在DEBUG模式下设为YES, RELEASE设为NO;</li><li>模拟器并不运行arm代码, 软件会被编译成x86可以运行的指令. 所以生成静态库时都是会先生成两个.a, 一个是i386的用于在模拟器运行, 另一个是在真实设备上运行的, 然后再用命令将两个.a合并成一个.</li></ul></li><li>模拟器和真机所需框架<ul><li>模拟器32位需要 i386 框架</li><li>模拟器64位需要 x86_64 框架</li><li>真机32位需要 armv7 或 armv7s 框架</li><li>真机64位需要 arm64 框架</li></ul></li></ol><h1 id="arm报错问题"><a href="#arm报错问题" class="headerlink" title="arm报错问题"></a>arm报错问题</h1><h2 id="1-error-No-architectures-to-compile-for-ONLY-ACTIVE-ARCH-YES-active-arch-x86-64-VALID-ARCHS-i386"><a href="#1-error-No-architectures-to-compile-for-ONLY-ACTIVE-ARCH-YES-active-arch-x86-64-VALID-ARCHS-i386" class="headerlink" title="1. error: No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386)"></a>1. error: No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 在 `Project target` 里 `Architectures` 设置为 `Standard （armv7,armv7s）`</div><div class="line">2. 修改在 `Project target` 里 `Build Settings` 的 `Valid Architectures` 添加 `i386` 和 `armv7` (Xcode4.6 以上版本不再支持armv6，请去掉);</div><div class="line">3. 设置 `Build Active Architecture Only` 为 `NO`。</div></pre></td></tr></table></figure><h2 id="2-Undefined-symbols-for-architecture-arm64"><a href="#2-Undefined-symbols-for-architecture-arm64" class="headerlink" title="2. Undefined symbols for architecture arm64"></a>2. Undefined symbols for architecture arm64</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Undefined symbols for architecture arm64:</div><div class="line">&quot;_OBJC_CLASS_$_XXX&quot;, referenced from: someFile</div><div class="line">ld: symbol(s) not found for architecture arm64</div></pre></td></tr></table></figure><h3 id="reason-工程内某些地方不支持arm64指令集"><a href="#reason-工程内某些地方不支持arm64指令集" class="headerlink" title="reason: 工程内某些地方不支持arm64指令集 "></a><font color="#FF0000">reason: 工程内某些地方不支持arm64指令集 </font></h3><h3 id="resolve"><a href="#resolve" class="headerlink" title=" resolve: "></a><font color="#FF0000"> resolve: </font></h3><pre><code>1. 设置 Architectures armv7 armv7s, Build Active Architecture Only NO; Valid Architectures armv6 armv7 armv7s arm64;2. 如果设置 Architectures, Valid Architectures 设置正确还是不行的话, 在 Other Linker Flags 中添加$(inherited);3. 前面2步设置完还是不行的话试试:将 /User/yourname/Library/Developer/XCode/DerivedData 清空.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS的指令集有 &lt;code&gt;armv6、armv7、armv7s、arm64&lt;/code&gt; Arm是向下兼容的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;armv6 &lt;ul&gt;
&lt;li&gt;iPhone&lt;/li&gt;
&lt;li&gt;iPhone2&lt;/li&gt;
&lt;li&gt;iPhone3G&lt;/li&gt;
&lt;li&gt;i
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="CrashCollection" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/"/>
    
      <category term="arm指令集错误收集" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/arm%E6%8C%87%E4%BB%A4%E9%9B%86%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>崩溃日志</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/25/Objective-C/CrashCollection/%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/25/Objective-C/CrashCollection/崩溃日志/</id>
    <published>2017-04-25T10:19:52.000Z</published>
    <updated>2018-01-02T08:52:02.881Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/content/qa/qa1747/_index.html" target="_blank" rel="external">苹果崩溃日志文档</a></p><h2 id="崩溃日志的实例"><a href="#崩溃日志的实例" class="headerlink" title="崩溃日志的实例"></a>崩溃日志的实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">// 1: 进程信息</div><div class="line">Incident Identifier: 30E46451-53FD-4965-896A-457FC11AD05F</div><div class="line">CrashReporter Key:   5a56599d836c4f867f6eec76afee451bf9ae5f31</div><div class="line">Hardware Model:  iPhone4,1</div><div class="line">Process: Rage Masters [4155]</div><div class="line">Path:/var/mobile/Applications/A5635B22-F5EF-4CEB-94B6-FE158D885014/Rage Masters.app/Rage Masters</div><div class="line">Identifier:  Rage Masters</div><div class="line">Version: ??? (???)</div><div class="line">Code Type:   ARM (Native)</div><div class="line">Parent Process:  launchd [1]</div><div class="line">// 2: 基本信息</div><div class="line">Date/Time:   2012-10-17 21:39:06.967 -0400</div><div class="line">OS Version:  iOS 6.0 (10A403)</div><div class="line">Report Version:  104</div><div class="line">// 3: 异常</div><div class="line">Exception Type:  00000020</div><div class="line">Exception Codes: 0x000000008badf00d</div><div class="line">Highlighted Thread:  0</div><div class="line">// 4: 线程回溯</div><div class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</div><div class="line">Thread 0:</div><div class="line">0   libsystem_kernel.dylib0x327f2eb4 mach_msg_trap + 20</div><div class="line">1   libsystem_kernel.dylib0x327f3048 mach_msg + 36</div><div class="line">2   CoreFoundation0x36bd4040 __CFRunLoopServiceMachPort + 124</div><div class="line">3   CoreFoundation0x36bd2d9e __CFRunLoopRun + 878</div><div class="line">4   CoreFoundation0x36b45eb8 CFRunLoopRunSpecific + 352</div><div class="line">5   CoreFoundation0x36b45d44 CFRunLoopRunInMode + 100</div><div class="line">6   CFNetwork 0x32ac343e CFURLConnectionSendSynchronousRequest + 330</div><div class="line">7   Foundation0x346e69ba +[NSURLConnection sendSynchronousRequest:returningResponse:error:] + 242</div><div class="line">8   Rage Masters  0x000d4046 0xd2000 + 8262</div><div class="line">Thread 1:</div><div class="line">0   libsystem_kernel.dylib0x32803d98 __workq_kernreturn + 8</div><div class="line">1   libsystem_c.dylib 0x3a987cf6 _pthread_workq_return + 14</div><div class="line">2   libsystem_c.dylib 0x3a987a12 _pthread_wqthread + 362</div><div class="line">3   libsystem_c.dylib 0x3a9878a0 start_wqthread + 4</div><div class="line">// 5: 线程状态</div><div class="line">Thread 0 crashed with ARM Thread State (32-bit):</div><div class="line">r0: 0x00000000r1: 0x00000000  r2: 0x00000001  r3: 0x39529fc8</div><div class="line">r4: 0xffffffffr5: 0x2fd7d301  r6: 0x2fd7d300  r7: 0x2fd7d9d0</div><div class="line">r8: 0x2fd7d330r9: 0x3adbf8a8 r10: 0x2fd7d308 r11: 0x00000032</div><div class="line">ip: 0x00000025sp: 0x2fd7d2ec  lr: 0x001bdb25  pc: 0x30301838</div><div class="line">cpsr: 0x00000010</div><div class="line">// 6: 二进制映像</div><div class="line">Binary Images:</div><div class="line">0xd2000 -0xd7fff +Rage Masters armv7   /var/mobile/Applications/A5635B22-F5EF-4CEB-94B6-FE158D885014/Rage Masters.app/Rage Masters</div><div class="line">0x2fe41000 - 0x2fe61fff  dyld armv7   /usr/lib/dyld</div><div class="line">0x327f2000 - 0x32808fff  libsystem_kernel.dylib armv7   /usr/lib/system/libsystem_kernel.dylib</div><div class="line">0x328a8000 - 0x328bdfff  libresolv.9.dylib armv7   /usr/lib/libresolv.9.dylib</div><div class="line">0x32a70000 - 0x32b35fff  CFNetwork armv7   /System/Library/Frameworks/CFNetwork.framework/CFNetwork</div><div class="line">0x32b7a000 - 0x32cc3fff  libicucore.A.dylib armv7   /usr/lib/libicucore.A.dylib</div><div class="line">0x32cc4000 - 0x32cc5fff  CoreSurface armv7   /System/Library/PrivateFrameworks/CoreSurface.framework/CoreSurface</div><div class="line">0x32f65000 - 0x32f8afff  OpenCL armv7   /System/Library/PrivateFrameworks/OpenCL.framework/OpenCL</div></pre></td></tr></table></figure><h2 id="1-进程信息"><a href="#1-进程信息" class="headerlink" title="1. 进程信息"></a>1. 进程信息</h2><pre><code>* Incident Identifier 是崩溃报告的唯一标识符。* CrashReporter Key  是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到100个崩溃日志的CrashReporter Key值都是相同的，或者只有少数几个不同的CrashReport值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。* Hardware Model  标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是iPhone 4s。* Process  是应用名称。中括号里面的数字是闪退时应用的进程ID。</code></pre><h2 id="2-基本信息"><a href="#2-基本信息" class="headerlink" title="2. 基本信息"></a>2. 基本信息</h2><p>这部分给出了一些基本信息，包括闪退发生的日期和时间，设备的iOS版本。如果有很多崩溃日志都来自iOS 6.0，说明问题只发生在iOS 6.0上。 </p><h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h2><p>在这部分，你可以看到闪退发生时抛出的异常类型。还能看到异常编码和抛出异常的线程。根据崩溃报告类型的不同，在这部分你还能看到一些另外的信息。 </p><h2 id="4-线程回溯"><a href="#4-线程回溯" class="headerlink" title="4. 线程回溯"></a>4. 线程回溯</h2><p>这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。看下面这行日志:<br><code>2    XYZLib    0x34648e88    0x83000 + 8740</code><br><code>它包括四列:</code><br><code>1. 帧编号—— 此处是2。</code><br><code>2. 二进制库的名称 ——此处是 XYZLib.</code><br><code>3. 调用方法的地址 ——此处是 0x34648e88.</code><br><code>4. 第四列分为两个子列，一个基本地址和一个偏移量。此处是0×83000 + 8740, 第一个数字指向文件，第二个数字指向文件中的代码行。</code></p><h2 id="5-线程状态"><a href="#5-线程状态" class="headerlink" title="5. 线程状态"></a>5. 线程状态</h2><p>这部分是闪退时寄存器中的值。一般不需要这部分的信息，因为回溯部分的信息已经足够让你找出问题所在。 </p><h2 id="6-二进制映像"><a href="#6-二进制映像" class="headerlink" title="6. 二进制映像"></a>6. 二进制映像</h2><p>这部分列出了闪退时已经加载的二进制文件。</p><h2 id="低内存闪退"><a href="#低内存闪退" class="headerlink" title="低内存闪退"></a>低内存闪退</h2><p>被iOS因释放内存页终止的进程名称后面你会看到 jettisoned  字样。如果看到它出现在你的应用名称后面，说明你的应用因使用太多内存而被终止了。<br>低内存崩溃日志看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Incident Identifier: 30E46451-53FD-4965-896A-457FC11AD05F</div><div class="line">CrashReporter Key:   5a56599d836c4f867f6eec76afee451bf9ae5f31</div><div class="line">OS Version:          iPhone OS 3.1.3 (7E18)</div><div class="line">Date/Time:           2012-10-17 21:39:06.967 -0400</div><div class="line">Free pages:        96</div><div class="line">Wired pages:       10558</div><div class="line">Purgeable pages:   0</div><div class="line">Largest process:   Rage Masters</div><div class="line">Processes</div><div class="line">Name                 UUID                    Count resident pages</div><div class="line">Rage Masters     9320 (jettisoned) (active)</div><div class="line">mediaserverd      255</div><div class="line">dataaccessd      505</div><div class="line">syslogd       71</div><div class="line">apsd      171</div><div class="line">securityd      243</div><div class="line">notifyd     2027</div><div class="line">CommCenter      189</div><div class="line">SpringBoard     2158 (active)</div><div class="line">accessoryd       91</div><div class="line">configd      371</div><div class="line">fairplayd       93</div><div class="line">mDNSResponder      292</div><div class="line">lockdownd     1204</div><div class="line">launchd       72</div></pre></td></tr></table></figure></p><h2 id="异常编码"><a href="#异常编码" class="headerlink" title="异常编码"></a>异常编码</h2><ul><li>0x8badf00d : 读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的。  通常是应用花费太多时间而无法启动、终止或响应用系统事件。</li><li>0xbad22222 : 该编码表示 VoIP 应用因为过于频繁重启而被终止。</li><li>0xdead10cc : 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。</li><li>0xdeadfa11 : 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面。</li></ul><h3 id="从下向上读回溯日志。最底下的帧是最先调用的-依此类推。"><a href="#从下向上读回溯日志。最底下的帧是最先调用的-依此类推。" class="headerlink" title="从下向上读回溯日志。最底下的帧是最先调用的, 依此类推。"></a>从下向上读回溯日志。最底下的帧是最先调用的, 依此类推。</h3><h2 id="DEBUG模式下Crash搜集"><a href="#DEBUG模式下Crash搜集" class="headerlink" title="DEBUG模式下Crash搜集"></a>DEBUG模式下Crash搜集</h2><h3 id="1-SIGABRT（EXC-CRASH"><a href="#1-SIGABRT（EXC-CRASH" class="headerlink" title="1. SIGABRT（EXC_CRASH)"></a>1. SIGABRT（EXC_CRASH)</h3><pre><code>* 对象多次释放</code></pre><h3 id="2-EXC-BAD-ACCESS（SIGBUS-或-SIGSEGV）"><a href="#2-EXC-BAD-ACCESS（SIGBUS-或-SIGSEGV）" class="headerlink" title="2. EXC_BAD_ACCESS（SIGBUS 或 SIGSEGV）"></a>2. EXC_BAD_ACCESS（SIGBUS 或 SIGSEGV）</h3><p>通常是内存问题导致的, 这种情况通常很难定位, 因为有些会直接停在 main() 函数, Xcode 的 Debug 面板没有任何直接的错误信息, 开启异常断点只能得到部分错误信息, 想要的却没有; 有时可能需要多点几次, 才能得到错误信息; </p><pre><code>* NSUnknownKeyException 通常能够告诉我们错误的类型</code></pre><h3 id="3-异常断点"><a href="#3-异常断点" class="headerlink" title="3. 异常断点"></a>3. 异常断点</h3><pre><code>* objc_excption_rethrow 和 设置僵尸变量</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/content/qa/qa1747/_index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果崩溃日志文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;崩溃日志的
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="CrashCollection" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/"/>
    
      <category term="崩溃日志" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Keywords</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/22/Swift/Swift-Keywords/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/22/Swift/Swift-Keywords/</id>
    <published>2017-04-22T06:21:50.000Z</published>
    <updated>2018-01-10T10:17:00.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="guard关键字是什么"><a href="#guard关键字是什么" class="headerlink" title="guard关键字是什么"></a>guard关键字是什么</h2><p><code>“A guard statement, like an if statement, executes statements depending on the Boolean value of an expression. You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed. Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition is not true.”</code></p><ol><li>和if语句很相似，是否执行语句也是基于Boolean表达式，使用guard关键字需要条件为true才会让guard后面的语句执行;</li><li>必须有一个else语句，else语句块是条件不满足时需要执行的代码，此时结束函数执行；</li><li>else 中必须有一个return或者break；</li><li>个人理解为代码逻辑容错判断类似 assert。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func guardTest(say: String?)&#123;</div><div class="line">    guard let sayHi = say else &#123;</div><div class="line">        print(&quot;sayHi is nil&quot;)          ----------- 1</div><div class="line">        return                         ----------- 2</div><div class="line">    &#125;</div><div class="line">    print(sayHi)                       ----------- 3</div><div class="line">&#125;</div><div class="line">guardTest(say: nil)     // 此时会打印 &quot;sayHi is nil&quot;</div><div class="line">guardTest(say: &quot;hello&quot;) // 此时会直接走第三步</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;guard关键字是什么&quot;&gt;&lt;a href=&quot;#guard关键字是什么&quot; class=&quot;headerlink&quot; title=&quot;guard关键字是什么&quot;&gt;&lt;/a&gt;guard关键字是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;“A guard statement, like an 
      
    
    </summary>
    
      <category term="Swift" scheme="https://github.com/songMW/stack.github.io/categories/Swift/"/>
    
      <category term="Basic" scheme="https://github.com/songMW/stack.github.io/categories/Swift/Basic/"/>
    
      <category term="Keywords" scheme="https://github.com/songMW/stack.github.io/categories/Swift/Basic/Keywords/"/>
    
    
      <category term="Swift" scheme="https://github.com/songMW/stack.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Class-dump</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/21/Objective-C/Decompilation/Class-dump/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/21/Objective-C/Decompilation/Class-dump/</id>
    <published>2017-04-21T04:21:03.000Z</published>
    <updated>2018-01-02T08:55:36.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="class-dump-是什么"><a href="#class-dump-是什么" class="headerlink" title="class-dump 是什么?"></a>class-dump 是什么?</h2><p>使用<code>classdump</code>对原程序进行dum, 可以dump出所有源程序的函数所有信息：源程序所有函数类型，变量;<br>这样就可以了解程序结构方便逆向工程反编译.</p><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p><a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="external">官网</a></p><p>把 <code>class-dump</code> 放到 <code>/usr/local/bin</code> 目录下, 在终端输入<code>class-dump</code>, 显示<code>class-dump</code>的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">IDFA:~ mac$ class-dump</div><div class="line">class-dump 3.5 (64 bit)</div><div class="line">Usage: class-dump [options] &lt;mach-o-file&gt;</div><div class="line"></div><div class="line">where options are:</div><div class="line">-a             show instance variable offsets</div><div class="line">-A             show implementation addresses</div><div class="line">--arch &lt;arch&gt;  choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)</div><div class="line">-C &lt;regex&gt;     only display classes matching regular expression</div><div class="line">-f &lt;str&gt;       find string in method name</div><div class="line">-H             generate header files in current directory, or directory specified with -o</div><div class="line">-I             sort classes, categories, and protocols by inheritance (overrides -s)</div><div class="line">-o &lt;dir&gt;       output directory used for -H</div><div class="line">-r             recursively expand frameworks and fixed VM shared libraries</div><div class="line">-s             sort classes and categories by name</div><div class="line">-S             sort methods by name</div><div class="line">-t             suppress header in output, for testing</div><div class="line">--list-arches  list the arches in the file, then exit</div><div class="line">--sdk-ios      specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk</div><div class="line">--sdk-mac      specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk</div><div class="line">--sdk-root     specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut)</div></pre></td></tr></table></figure></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在终端输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IDFA:~ mac$ class-dump -H /Applications/WeChat.app -o /Users/mac/Desktop/Class-dump/weixin</div></pre></td></tr></table></figure></p><p>根据 class-dump options 解释:<br>-H 是生成在当前仓库生成头文件<br>-o 是输出到指定文件夹下</p><p><a href="https://github.com/nygard/class-dump">github上命令</a></p><p>下面是搜集github上常用的命令:</p><ul><li><p>class-dump AppKit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class-dump /System/Library/Frameworks/AppKit.framework</div></pre></td></tr></table></figure></li><li><p>class-dump UIKit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework</div></pre></td></tr></table></figure></li><li><p>class-dump UIKit and all the frameworks it uses:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-ios 4.3</div></pre></td></tr></table></figure></li><li><p>class-dump UIKit (and all the frameworks it uses) from developer tools that have been installed in /Dev42 instead of /Developer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class-dump /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-root /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk</div></pre></td></tr></table></figure></li></ul><p>上面的命令只是搜集, 没有一一验证.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;class-dump-是什么&quot;&gt;&lt;a href=&quot;#class-dump-是什么&quot; class=&quot;headerlink&quot; title=&quot;class-dump 是什么?&quot;&gt;&lt;/a&gt;class-dump 是什么?&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;classdump&lt;/c
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="Decompilation" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/Decompilation/"/>
    
      <category term="Class-dump" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/Decompilation/Class-dump/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>BasicOperators</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/20/Swift/Swift-BasicOperators/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/20/Swift/Swift-BasicOperators/</id>
    <published>2017-04-20T06:20:16.000Z</published>
    <updated>2018-01-10T10:16:49.659Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Swift" scheme="https://github.com/songMW/stack.github.io/categories/Swift/"/>
    
      <category term="Basic" scheme="https://github.com/songMW/stack.github.io/categories/Swift/Basic/"/>
    
      <category term="BasicOperators" scheme="https://github.com/songMW/stack.github.io/categories/Swift/Basic/BasicOperators/"/>
    
    
      <category term="Swift" scheme="https://github.com/songMW/stack.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>TheBasic</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/19/Swift/Swift-TheBasic/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/19/Swift/Swift-TheBasic/</id>
    <published>2017-04-19T04:21:50.000Z</published>
    <updated>2018-01-10T10:17:12.947Z</updated>
    
    <content type="html"><![CDATA[<ol><li>option is similar to using nil with pointers in Objective-C, work for any type option (?) 和 nil 相似, 可以用于任何类型, 不仅仅是类,如果有值那么就是显示该值, 如果没有值则为nil;</li><li>Swift is a type-safe language, which means the language helps you to clear about the types of values your code can work with. Swift 是类型安全语言, 意味着Swift可以帮助你分析变量类型.</li></ol><h2 id="Constants-and-Variables"><a href="#Constants-and-Variables" class="headerlink" title="Constants and Variables"></a>Constants and Variables</h2><ol><li><p>Constants cannot be changed once it is set, declare contants with the ‘let’ keyword声明常量使用关键字 let, 一旦设置值后不能被改变;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//声明一个新的常量叫 maximunNumberOfLogingAttempts 并给他一个值10</div><div class="line">let maximunNumberOfLogingAttempts = 10</div><div class="line">//如果尝试修改 maximunNumberOfLogingAttempts 的值编译器会报错</div><div class="line">//maximunNumberOfLogingAttempts = 11</div><div class="line">//Cannot assign to value: &apos;maximunNumberOfLogingAttempts&apos; is a &apos;let&apos; constant</div></pre></td></tr></table></figure></li><li><p>Variable can be set to a different value in the future, declare variable with the ‘var’ keyword 声明变量使用关键字 var, 可以设置不同的值;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//声明一个变量叫 str 并给他一个值 &quot;Hello, playground&quot;</div><div class="line">var str = &quot;Hello, playground&quot;</div><div class="line">str = &quot;I am changed!&quot;</div><div class="line">//使用 commas(,) 来同时声明多个变量</div><div class="line">var x = 0.0, y = 0.0, z = 0.0</div></pre></td></tr></table></figure></li><li><p>如果在代码中存储一个值不在改变, 通常使用’let’关键字来声明它为常量;<br>如果在代码中存储一个值会改变, 通常使用 ‘var’关键字声明它为变量;</p></li></ol><h2 id="Type-Annotations-键入注释"><a href="#Type-Annotations-键入注释" class="headerlink" title="Type Annotations 键入注释"></a>Type Annotations 键入注释</h2><ul><li>当你声明一个常量或者变量时可以提供一个键入注释来清楚的描述这个常量或者变量存储的是什么类型, 在常量或者变量名后加一个冒号(:)接着是一个空格,然后是使用的类型, var welcomeMessage: String 意思是为 welcomeMessage 提供一个键入注释, 指明这个变量可以存储 String 类型的值 –&gt; 声明一个变量 welcomeMessage 的类型是 String</li></ul><h2 id="Tuples-元组"><a href="#Tuples-元组" class="headerlink" title="Tuples 元组"></a>Tuples 元组</h2><ul><li>将多个值组合成一个单一的复合值, 这些值的类型可以是任何类型, 也可以是混合类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">let http404Error = (404, &quot;Not Found&quot;)</div><div class="line">// http404Error is of type (Int, String) equals (404, &quot;Not Found&quot;)</div><div class="line">// Described as a tuple of type (Int, String)</div><div class="line">// 创建元组是无序的, 可以包含许多不同类型的类型 (Int, Int, Int) or (String, Bool) or 其他任何需要的排列组合</div><div class="line">// 元组的获取: 可以将元组分解为常量或变量, 然后用寻常的方法获取它们</div><div class="line">let (statusCode, statusMessage) = http404Error</div><div class="line">print(&quot;The status code is \(statusCode)&quot;)</div><div class="line">print(&quot;The status message is \(statusMessage)&quot;)</div><div class="line">// 如果只需要元组内特定的值, 可以使用 &quot;_&quot; 来忽略其他</div><div class="line">let (justTheStatusCode, _) = http404Error</div><div class="line">print(&quot;The status code is \(justTheStatusCode)&quot;)</div><div class="line">// 创建元组没有名称</div><div class="line">let (p1, p2, p3) = (1, 2, 3)</div><div class="line">print(p1)</div><div class="line">print(p2)</div><div class="line">print(p3)</div><div class="line"></div><div class="line">let testTuple = (1, 2, 3)</div><div class="line">let (test1, test2, test3) = testTuple</div><div class="line">// 元组内元素个数要对应</div><div class="line">let (onlyTest1, _, _) = testTuple</div><div class="line">print(onlyTest1)</div><div class="line"></div><div class="line">// 也可以使用元组的下标获取元组单独的元素值, 下标从0开始</div><div class="line">print(&quot;The status code is \(http404Error.0)&quot;)</div><div class="line">print(&quot;The status message is \(http404Error.1)&quot;)</div><div class="line">// 定义一个元组时可以为单独的元素命名</div><div class="line">let http200Status = (statusCode: 200, description: &quot;OK&quot;)</div><div class="line">// 此时获取元组的元素使用变量名.元素名</div><div class="line">print(&quot;The status code is \(http200Status.statusCode)&quot;)</div><div class="line">print(&quot;The status message is \(http200Status.description)&quot;)</div></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><ol><li>使用optional的情形是在值可能缺失的情况下</li><li>nil 可以给一个可选类型的变量赋值为nil</li><li>nil 不能用于没有可选类型的常量或变量</li><li>Swift 中 nil 与 Objective-C 中 nil 区别?<br><code>OC中 nil 指向一个不存在的对象;</code><br><code>Swift 中 nil 不是一个指针, 它是某种确定类型值的缺失, 任何可选类型都可以设置为nil, 而不仅仅是对象</code></li></ol><h2 id="if-statement-and-force-unwrapping"><a href="#if-statement-and-force-unwrapping" class="headerlink" title="if statement and force unwrapping"></a>if statement and force unwrapping</h2><ol><li>针对可选类型值判断</li><li>! 告诉编译器: 知道这个可选类型的变量有值, 即强制拆包<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var statemetValue: String? = &quot;a value&quot;</div><div class="line">if statemetValue != nil &#123;</div><div class="line">//statementValue has a certain value Optional(&quot;a value&quot;)</div><div class="line">    print(&quot;statementValue has a certain value \(statemetValue)&quot;)</div><div class="line">//statementValue has a certain value a value</div><div class="line">    print(&quot;statementValue has a certain value \(statemetValue!)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="Optional-Binding-可选绑定"><a href="#Optional-Binding-可选绑定" class="headerlink" title="Optional Binding 可选绑定"></a>Optional Binding 可选绑定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">下面代码解释为:</div><div class="line">如果 Int(possibleNumber!) 返回一个 Int 的值, 那么就设置一个新的常量 actualNumber(不是可选类型) 接收它的值</div><div class="line">如果转换失败, 则执行 else</div><div class="line">var possibleNumber: String? = &quot;123&quot;//&quot;hello world&quot;</div><div class="line">if let actualNumber = Int(possibleNumber!) &#123;</div><div class="line">    print(&quot;\(possibleNumber) has an integer value of \(actualNumber)&quot;)</div><div class="line">    print(&quot;\(actualNumber)&quot;)</div><div class="line">&#125; </div><div class="line">else &#123;</div><div class="line">    print(&quot;\(possibleNumber) could not be converted to an integer&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Implicitly-Unwrapped-Optionals-隐式解包"><a href="#Implicitly-Unwrapped-Optionals-隐式解包" class="headerlink" title="Implicitly Unwrapped Optionals 隐式解包"></a>Implicitly Unwrapped Optionals 隐式解包</h2><ol><li>如果变量是可选类型, 隐式解包时需要 ! </li><li>如果变量可以确定是有值的, 则不需要隐式解包</li><li>如果可选类型变量没有值,即默认是nil时, 不能使用隐式解包, 否则会报错</li><li>可以使用 if 语句来检测可选类型的值和普通的可选类型一样<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var possibleString: String? = &quot;hello world&quot;</div><div class="line">var actualString = possibleString!</div><div class="line">    print(&quot;\(actualString) is not optional type&quot;)</div><div class="line"></div><div class="line">var possibleStringActual: String! = &quot;actual value&quot;</div><div class="line">actualString  = possibleStringActual</div><div class="line">    print(&quot;\(actualString) is not optional type and not need exclamation mark(!)&quot;)</div><div class="line"></div><div class="line">var possibleStringNotValue: String?</div><div class="line">if let testString = possibleStringNotValue &#123;</div><div class="line">    print(&quot;testString has a value is \(possibleStringNotValue)&quot;)</div><div class="line">&#125;</div><div class="line">else&#123;</div><div class="line">    print(&quot;possibleStringNotValue is nil&quot;)</div><div class="line">&#125;</div><div class="line">//actualString = possibleStringNotValue!</div><div class="line">//fatal error: unexpectedly found nil while unwrapping an Optional value</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;option is similar to using nil with pointers in Objective-C, work for any type option (?) 和 nil 相似, 可以用于任何类型, 不仅仅是类,如果有值那么就是显示该值, 如
      
    
    </summary>
    
      <category term="Swift" scheme="https://github.com/songMW/stack.github.io/categories/Swift/"/>
    
      <category term="Basic" scheme="https://github.com/songMW/stack.github.io/categories/Swift/Basic/"/>
    
      <category term="TheBasic" scheme="https://github.com/songMW/stack.github.io/categories/Swift/Basic/TheBasic/"/>
    
    
      <category term="Swift" scheme="https://github.com/songMW/stack.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>unrecognizedSelector</title>
    <link href="https://github.com/songMW/stack.github.io/2017/04/18/Objective-C/CrashCollection/unrecognizedSelector/"/>
    <id>https://github.com/songMW/stack.github.io/2017/04/18/Objective-C/CrashCollection/unrecognizedSelector/</id>
    <published>2017-04-18T06:37:39.000Z</published>
    <updated>2018-01-02T08:52:33.784Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，可以通过“消息转发”进行解决;</li><li>对象查找selector时，先查找cachelist，如果没有则查找methodlist，如果还没有就查找父类的methodlist;</li><li>都没有查找到时会三次机会可以处理这次selector访问</li></ol><h2 id="Objective-C提供两类消息转发方式"><a href="#Objective-C提供两类消息转发方式" class="headerlink" title="Objective-C提供两类消息转发方式:"></a>Objective-C提供两类消息转发方式:</h2><ul><li>快速转发: NSObject 类的子类重载 NSObject 的 <code>forwardingTargetForSelector:</code>方法,将该方法转发给其他对象, 实现快速转发. 将对象的实现代码和转发对象合并到一起, 类似于实现了多继承, 使用此方法的技巧是定义了一个类可以消化目标类未实现的方法.</li><li>完整转发: NSObject 类的子类重载 NSObject 的 <code>forwardInvacation:</code>方法, 实现标准转发, 使用此方法要能够使用消息的全部内容(目标, 方法, 参数)</li></ul><h3 id="1-快速转发"><a href="#1-快速转发" class="headerlink" title="1. 快速转发:"></a>1. 快速转发:</h3><h3 id="使用需求-转发对象所在类所需实现当前要转发的方法"><a href="#使用需求-转发对象所在类所需实现当前要转发的方法" class="headerlink" title="使用需求: 转发对象所在类所需实现当前要转发的方法"></a><font color="#FF0000">使用需求: 转发对象所在类所需实现当前要转发的方法</font></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        //初始化一个转发对象</div><div class="line">        _helper = [[HydrogenHelper alloc]init];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    //在指定类中的执行已实现的方法(和aSelector同名, 同参数)</div><div class="line">    if ([_helper respondsToSelector:aSelector]) &#123;</div><div class="line">        return _helper;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">    </div><div class="line">    //或者可以直接 return _helper; 意思是当前类未实现的方法都会转发到 _helpe 类;</div><div class="line">    //但是 aSelector 这个方法在 _helper 类中必须有实现, 如果未实现则还是会报错</div><div class="line">&#125;</div><div class="line"></div><div class="line">调用栈信息执行顺序与 Xcode 上相反:</div><div class="line">1. start</div><div class="line">2. __invoking__</div><div class="line">3. [xxx 调用未实现的method]</div><div class="line">4. __forwarding_prep_0___</div><div class="line">5. ___forwarding___</div><div class="line">6. [Class forwordingTargetForSelector:]</div></pre></td></tr></table></figure><h3 id="2-标准转发"><a href="#2-标准转发" class="headerlink" title="2. 标准转发:"></a>2. 标准转发:</h3><h3 id="使用需求-当前类实现够使用消息的全部内容-目标-方法-参数"><a href="#使用需求-当前类实现够使用消息的全部内容-目标-方法-参数" class="headerlink" title="使用需求: 当前类实现够使用消息的全部内容(目标, 方法, 参数)"></a><font color="#FF0000">使用需求: 当前类实现够使用消息的全部内容(目标, 方法, 参数)</font></h3><ul><li><p>如果实现 <code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code> 这个方法, 则会首先执行它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    class_addMethod(self.class, sel, (IMP)dynamicMethod, &quot;@@:&quot;);</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">id dynamicMethod(id self, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;%s:动态添加的方法&quot;,__FUNCTION__);</div><div class="line">    return @&quot;LogMsg&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果动态添加方法成功, 则执行 dynamicMethod , 转发结束;</div><div class="line"></div><div class="line">调用栈信息执行顺序与 Xcode 上相反:</div><div class="line">1. start</div><div class="line">2. __invoking__</div><div class="line">3. [xxx 调用未实现的method]</div><div class="line">4. _objc_msgSend_uncached</div><div class="line">5. _class_resoveInstanceMethod(objc_class *, objc_selector *, objc_object *)</div><div class="line">6. [Class resolveInstanceMethod:]</div></pre></td></tr></table></figure></li><li><p>如果 <code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code> 这个方法没有实现或者动态添加方法失败, 则会执行 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector </div><div class="line">&#123;</div><div class="line">    id result = [super forwardingTargetForSelector:aSelector];</div><div class="line">    return result;</div><div class="line"></div><div class="line">    //或者执行快速转发</div><div class="line">&#125;</div><div class="line"></div><div class="line">只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启</div></pre></td></tr></table></figure></li><li><p>如果 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 没有实现或者返回 nil 或 self, 则会执行最后一次拯救</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    id result = [super methodSignatureForSelector:@selector(logInfo:)];</div><div class="line">    return result;</div><div class="line">&#125; </div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    anInvocation.selector = (SEL)dynamicMethod;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)logInfo:(NSString *)str</div><div class="line">&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">只有 result 返回有值的时候才会执行 forwardInvocation: 否则不执行;</div><div class="line">这就需要提前在类中实现好要去执行的方法</div><div class="line"></div><div class="line">调用栈信息执行顺序与 Xcode 上相反:</div><div class="line">1. start</div><div class="line">2. __invoking__</div><div class="line">3. __forwarding_prep_0___</div><div class="line">4. ___forwarding___</div><div class="line">5. [Class methodSignatureForSelector:]</div><div class="line">6. [Class forwardInvocation:]</div></pre></td></tr></table></figure></li><li><p>如果都执行失败执行 <code>doesNotRecognizeSelector:</code> 会抛出异常.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当调用该对象上某个方法,而该对象上没有实现这个方法的时候，可以通过“消息转发”进行解决;&lt;/li&gt;
&lt;li&gt;对象查找selector时，先查找cachelist，如果没有则查找methodlist，如果还没有就查找父类的methodlist;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/"/>
    
      <category term="CrashCollection" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/"/>
    
      <category term="unrecognizedSelector" scheme="https://github.com/songMW/stack.github.io/categories/Objective-C/CrashCollection/unrecognizedSelector/"/>
    
    
      <category term="Objective-C" scheme="https://github.com/songMW/stack.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>
